2021-11-09 21:08
#tag
# Container_docker
#### **Создаем Docker контейнер**
```bash
micro  1.py 		# создаём скрипт py для запуска в контейнере
micro  Dockerfile	# создаём Dockfile - в него что ниже
```
```Dockerfile
FROM python:3.6-alpine3.8          
# Скачиваем легковесный образ python-alpine |  https://hub.docker.com/_/python?tab=description
COPY 1.py /app/                    
# Копируем 1.py с компьютера в дирректорию /app образа
WORKDIR /app                       
# Делаем /app рабочей дирректорией для след. команды
ENTRYPOINT ["python3", "/app/1.py"]
# Говорим "Питон3, запусти приложение /app/1.py"
```
```bash
						# Собираем наш Докер-образ. 
# В терминале, в директории с Докерфайлом и приложением запускаем команду:
docker build . -t py_app:v0.1
```
-------------------------------------------
```bash
							" Создание образа"
docker build ПУТЬ | URL		# создает образ с помощью Dockerfile  
    		-t | --tag=""	# помечает созданный образ переданным названием (и, тэгом, если он будет передан)
    		--rm			# удаляет промежуточные контейнеры после успешной сборки по умолчанию == true)
# из каталога, в котором находится Dockerfile:
docker build -t linuxize:tag . 	# Параметр `-t` указывает имя изображения ,: необязательно тег в формате «name:тег» 
								# . выбор docker фаила ЛОКАЛЬНО(в рабочей dir)
```
#### MultiStage_сборка [](https://stepik.org/lesson/550143/step/3?unit=543780)
```go
package main

import (
    "fmt"
    "log"
    "net/http"
)
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
}
func main() {
    http.HandleFunc("/", handler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
сохранить как main.go и собрать следующим Dockerfile'ом
__**`V1`**__
```Dockerfile
FROM golang:1.10 
RUN mkdir /app 
ADD . /app/ 
WORKDIR /app 
RUN go build -o main . 
CMD ["/app/main"]
```
`docker build . -t go:v0.1`

__**`V1`**__  v0.2 (`MultiStage`)
```Dockerfile
FROM golang:1.10 AS builder              
# Создаем временный Докер-образ и называем его builder                    
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .


FROM alpine:latest                       
# Создаем финальный Докер-образ на базе легковесного alpine
RUN apk --no-cache add ca-certificates  
WORKDIR /root/
COPY --from=builder ./app .              
# Копируем собранное приложение из образа biulder
EXPOSE 8080
CMD ["./app"]
```
`docker images` - Докерфайл`v2` дал нам образ `в 50 раз меньше` 
В первом Докерфайле мы сказали Докеру собрать образ, в котором будет Golang версии 1.10, а также наше приложение. Но Go - это компилируемый язык, его артефакт - исполняемый бинарный файл, который не обязательно запускать, имея рядышком достаточно тяжеловесный `компилятор Golang`, он нам `нужен лишь при сборке приложения` ==> в Докерфайле`v2` мы использовали Golang и **`собрали бинарь в первом этапе`**, а **`во втором`** этапе мы использовали легковесный `Alpine, чтобы запускать наше приложение` :) 

А еще мы только что сделали первый веб-сервис в Докере
_____________________________________

#### Файлы [Dockerfile](https://routerus.com/how-to-build-docker-images-with-dockerfile/)
Best practice: 
 - `.dockerignore` (как gitignore)
 - команды `RUN` через && (apt update && apt upgrade) `снижаем кол-во слоёв`
 - отчистить `cache` atp
 - выбираем `minimal Linux` (Alpine 8mb ) Debian 200 mb
 - часто изменяемые слои\файлы (проэкт) `размещаем внизу DOCKER FILE`
 - прописывать `версии` ОС и приложух (МОЖНО ЧЕРЕЗ `ENV`)(+указывать репозиторий)
 - `Multi-stage` сборка
 
Рекомендации [по написанию файлов Docker](https://routerus.com/goto/https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) .
```DOCKER FILE
FROM ОБРАЗ | FROM ОБРАЗ:ТЭГ    
# Задает базовый образ для последующих инструкций. Может встречаться несколько раз в одном Dockerfile, если необходимо собрать несколько образов за раз.
MAINTAINER имя    
# Позволяет задать поле _Author_ сгенерированного образа
RUN команда | RUN ["исполняемый файл", "параметр1", "параметр2", ..]    
# Запускает команду на основе текущего образа и фиксирует изменения в новом образе. 
# Новый образ будет использован для исполнения последующих инструкций. Первый синтаксис подразумевает запуск команд в стандартной оболочке (bin\\sh -c)
CMD ["исполняемый файл", "параметр1", "параметр2"] | CMD ["параметр1", "параметр2"] | CMD команда параметр1 параметр2    
# Предоставляет значения по умолчанию для запуска контейнера. Эти значения могут как включать исполняемый файл (варианты 1, 3), так и не включать его (вариант 2). В последнем случае запускаемая команда  должна быть задана с помощью инструкции `ENTRYPOINT`.
EXPOSE порт <порт...>    
# Информирует Docker, что контейнер будет прослушивать указанные порты во время исполнения. Docker может использовать эту информацию, чтобы соединять контейнеры между собой используя связи. `EXPOSE` сам по себе не делает порт доступным из хостовой системы. Для того, чтобы открыть порты в хостовую систему следует использовать флаг `-p`.
ENV ключ значение    
# Позволяет задавать переменные окружения. Эти переменные будут использованы при запуске контейнера из собранного образа. Могут быть просмотрены с помощью команды `docker inspect`, а также переопределены с помощью флага `--env` команды `docker run`.
ADD ОТКУДА <ОТКУДА...> КУДА    
# Используется для добавления новых файлов, директорий или ссылок на удалённые файлы в файловую систему контейнера. Несколько ОТКУДА может быть передано одновременно, но в этом случае все адреса должны быть относительны для директории, из которой происходит сборка. Каждый вхождение ОТКУДА может содержатьодин или несколько символов подстановки, которые будут разрешены с использование функции языка Go filepath.Match. КУДА должен быть абсолютным путем внутри контейнера.
ENTRYPOINT ["исполняемый файл", "параметр1", "параметр2"] | ENTRYPOINT команда параметр1 параметр2    
# позволяет сконфигурировать контейнер так, чтобы он запускался как исполняемый файл. В отличии от команды `CMD` значение не будет переопределено аргументами, переданными в команду `docker run`. Таким образом, аргументы из команды `docker run` будут переданы внутрь контейнера, т.е. `docker run ОБРАЗ -d` передаст -d исполняемому файлу.
VOLUME [ПУТЬ]    
# создает точку монтирования с указанным именем и помечает её как содержащую подмонтированные разделы из хостовой системы или других контейнеров. Значение может быть задано как массив JSON, например, `VOLUME ["/var/log/"]`, так и как обычной строкой с одним или несколькими аргументами, например `VOLUME /var/log` или `VOLUME /var/log /var/db`
USER имя    
# позволяет задавать имя пользователя или UID, который будет использован для запуска образа, а так же для любой из инструкций `RUN`
WORKDIR ПУТЬ    
# задает рабочую директорию для команд `RUN`, `CMD` и `ENTRYPOINT`. Инструкция может быть использована несколько раз. Если ПУТЬ относителен, то он будет относительным для ПУТИ, заданным предыдущей инструкцией `WORKDIR`
```
__**Ex**__
```dockerfile
# nano/vim/micro Dockerfile - создайте txt document: Dockerfile
FROM ubuntu:18.04					# определяем базовое изображение
"Каждую команду выполнять отделбно НЕ чепез &&"
RUN apt-get update 		 			# обновит индекс apt and
RUN apt-get install -y redis-server # установит пакет «redis-server» and
RUN apt-get clean					# очистит кеш apt

EXPOSE 6379									# определяет порт, который прослушивает сервер Redis
CMD ["redis-server", "--protected-mode no"] # команды по умолчанию, которая будет выполняться при запуске контейнера.
# ____________________________________________________
FROM ubuntu:16.04

RUN apt-get -y update
RUN apt-get -y install apache2
RUN echo 'Hello World from Docker!' > /var/www/html/index.html

CMD ["/usr/sbin/apache2ctl", "-D","FOREGROUND"]
EXPOSE 80
```
Следующим шагом будет создание образа.


_____________
#### Links
[[VirtualOS]] | [[Docker]]