2021-09-27 19:02
[wiki](https://ru.wikipedia.org/wiki/HTTP) [+](https://developer.mozilla.org/en-US/docs/Web/HTTP/Session)
# HTTP
**HTTP** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") HyperText Transfer Protocol — «протокол передачи [гипертекста](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%82%D0%B5%D0%BA%D1%81%D1%82 "Гипертекст")») — [протокол](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%BE%D0%B9_%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB "Сетевой протокол") [прикладного уровня](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D1%8B_%D0%BF%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F "Протоколы прикладного уровня") передачи данных, изначально — в виде гипертекстовых документов в формате [HTML](https://ru.wikipedia.org/wiki/HTML "HTML"), в настоящее время используется для передачи произвольных данных.
Основой HTTP является [технология «клиент-сервер»](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80 "Клиент-сервер")
Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ».
HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «[куки](https://ru.wikipedia.org/wiki/HTTP_cookie "HTTP cookie")» на стороне клиента, «сессии» на стороне сервера)
HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные.
#### Структура_HTTP-сообщения
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
1. [Стартовая строка](##Стартовая_строка)  — определяет тип сообщения:
	-   [Метод](##Методы) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод `GET`, список методов для версии 1.1 представлен ниже.
	-   [URI] определяет путь к запрашиваемому документу.
	-   Версия  — пара разделённых точкой  Например: `1.0`.
2.  Заголовки  — характеризуют тело сообщения, параметры передачи и прочие сведения;
3.  Тело сообщения  — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.
  
#### Содержание
- [1 Основные свойства](###Основные_свойства)
- [2 Программное обеспечение](https://ru.wikipedia.org/wiki/HTTP#Программное_обеспечение)
    -   [2.1 Клиенты](https://ru.wikipedia.org/wiki/HTTP#Клиенты)
    -   [2.2 Исходные серверы](https://ru.wikipedia.org/wiki/HTTP#Исходные_серверы)
    -   [2.3 Прокси-серверы](https://ru.wikipedia.org/wiki/HTTP#Прокси-серверы)
- [3 Структура HTTP-сообщения](##Структура_HTTP-сообщения)
    -   [3.1 Стартовая строка](##Стартовая_строка)
    -   [3.2 Методы](##Методы)
        -   [3.2.1 OPTIONS](##OPTIONS)
        -   [3.2.2 GET](##GET)
        -   [3.2.3 HEAD](##HEAD)
        -   [3.2.4 POST](##POST)
        -   [3.2.5 PUT](##PUT)
        -   [3.2.6 PATCH](##PATCH)
        -   [3.2.7 DELETE](##DELETE)
        -   [3.2.8 TRACE](##TRACE)
        -   [3.2.9 CONNECT](##CONNECT)
    -   [3.3 Коды состояния](#Коды_состояния)
    -   [3.4 Заголовки](#Заголовки)
    -   [3.5 Тело сообщения](#Тело_сообщения)
- [4 Примеры диалогов HTTP](#Примеры_диалогов_HTTP)
- [5 Основные механизмы протокола](#Основные_механизмы_протокола)
    -   [5.1 Частичные GET](#Частичные_GET)
    -   [5.2 Условные GET](#Условные_GET)
    -   [5.3 Согласование содержимого](https://ru.wikipedia.org/wiki/HTTP#Согласование_содержимого)
        -   [5.3.1 Управляемое сервером](https://ru.wikipedia.org/wiki/HTTP#Управляемое_сервером)
        -   [5.3.2 Управляемое клиентом](https://ru.wikipedia.org/wiki/HTTP#Управляемое_клиентом)
        -   [5.3.3 Прозрачное согласование](https://ru.wikipedia.org/wiki/HTTP#Прозрачное_согласование)
    -   [5.4 Множественное содержимое](https://ru.wikipedia.org/wiki/HTTP#Множественное_содержимое)
### Основные_свойства
Основой HTTP является [технология «клиент-сервер»](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80 "Клиент-сервер"), то есть предполагается существование:

-   Потребителей ([клиентов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9) "Клиент (программный)")), которые инициируют соединение и посылают запрос;
-   Поставщиков ([серверов](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) "Сервер (приложение)")), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

HTTP в настоящее время повсеместно используется во [Всемирной паутине](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0 "Всемирная паутина") для получения информации с [веб-сайтов](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D1%81%D0%B0%D0%B9%D1%82 "Веб-сайт"). В [2006 году](https://ru.wikipedia.org/wiki/2006_%D0%B3%D0%BE%D0%B4 "2006 год") в [Северной Америке](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B2%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%90%D0%BC%D0%B5%D1%80%D0%B8%D0%BA%D0%B0 "Северная Америка") доля HTTP-[трафика](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F "Информация") превысила долю [P2P-сетей](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B8%D0%BD%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D0%B5%D1%82%D0%B8 "Пиринговые сети") и составила 46 %, из которых почти половина — это передача [потокового](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D0%B4%D0%B8%D0%B0 "Потоковое мультимедиа") видео и звука[[1]](https://ru.wikipedia.org/wiki/HTTP#cite_note-1).

HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как [SOAP](https://ru.wikipedia.org/wiki/SOAP "SOAP"), [XML-RPC](https://ru.wikipedia.org/wiki/XML-RPC "XML-RPC"), [WebDAV](https://ru.wikipedia.org/wiki/WebDAV "WebDAV").

Основным объектом манипуляции в HTTP является ресурс, на который указывает [URI](https://ru.wikipedia.org/wiki/URI "URI") (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере [файлы](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB "Файл"), но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и [ответе](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0#Взаимодействие_с_веб-сервером_(HTTP) "Код ответа") способ представления одного и того же ресурса по различным параметрам: [формату](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D1%82_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Формат данных"), [кодировке](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BE%D1%80_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2 "Набор символов"), языку и т. д. (в частности, для этого используется [HTTP-заголовок](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP "Заголовки HTTP")). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться [двоичными данными](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5 "Двоичные данные"), хотя данный протокол является текстовым.

HTTP — протокол [прикладного уровня](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI "Модель OSI"); аналогичными ему являются [FTP](https://ru.wikipedia.org/wiki/File_Transfer_Protocol "File Transfer Protocol") и [SMTP](https://ru.wikipedia.org/wiki/SMTP "SMTP"). Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные [URI](https://ru.wikipedia.org/wiki/URI "URI"). В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «[куки](https://ru.wikipedia.org/wiki/HTTP_cookie "HTTP cookie")» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить [IP-адреса](https://ru.wikipedia.org/wiki/IP-%D0%B0%D0%B4%D1%80%D0%B5%D1%81 "IP-адрес") и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.

Большинство протоколов предусматривает установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются [cookies](https://ru.wikipedia.org/wiki/Cookies "Cookies"); причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.

При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с [CGI](https://ru.wikipedia.org/wiki/CGI "CGI")-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может порождать ответы разных типов — в простейшем случае картинки в разных форматах).

Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в [HTML](https://ru.wikipedia.org/wiki/HTML "HTML") были введены формы.

Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой [DEC](https://ru.wikipedia.org/wiki/DEC "DEC")), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.

### Программное_обеспечение

Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:

-   Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);
-   Клиенты — конечные потребители услуг сервера (отправка запроса);
-   Прокси (посредники) для выполнения транспортных служб.

Для отличия конечных серверов от прокси в официальной документации используется термин «исходный сервер» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") origin server). Один и тот же программный продукт может одновременно выполнять функции клиента, сервера или посредника в зависимости от поставленных задач. В спецификациях протокола HTTP подробно описывается поведение для каждой из этих ролей.

### Клиенты

Первоначально протокол HTTP разрабатывался для доступа к гипертекстовым документам Всемирной паутины. Поэтому основными реализациями клиентов являются [браузеры](https://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80 "Браузер") (агенты пользователя). Для просмотра сохранённого содержимого сайтов на компьютере без соединения с Интернетом были придуманы [офлайн-браузеры](https://ru.wikipedia.org/wiki/%D0%9E%D1%84%D0%BB%D0%B0%D0%B9%D0%BD-%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80 "Офлайн-браузер"). При нестабильном соединении для загрузки больших файлов используются [менеджеры закачек](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80_%D0%B7%D0%B0%D0%BA%D0%B0%D1%87%D0%B5%D0%BA "Менеджер закачек"); они позволяют в любое время докачать указанные файлы после потери соединения с веб-сервером. Некоторые виртуальные атласы (такие как [Google Планета Земля](https://ru.wikipedia.org/wiki/Google_%D0%9F%D0%BB%D0%B0%D0%BD%D0%B5%D1%82%D0%B0_%D0%97%D0%B5%D0%BC%D0%BB%D1%8F "Google Планета Земля") и [NASA World Wind](https://ru.wikipedia.org/wiki/NASA_World_Wind "NASA World Wind")) тоже используют HTTP.

Нередко протокол HTTP используется программами для скачивания обновлений.

Целый комплекс программ-роботов используется в [поисковых системах](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Поисковая система") Интернета. Среди них веб-пауки ([краулеры](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9_%D1%80%D0%BE%D0%B1%D0%BE%D1%82 "Поисковый робот")), которые производят проход по гиперссылкам, составляют базу данных ресурсов серверов и сохраняют их содержимое для дальнейшего анализа.

### Исходные_серверы

См. также: [Список веб-серверов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B2%D0%B5%D0%B1-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%B2 "Список веб-серверов")

Основные реализации: [Apache](https://ru.wikipedia.org/wiki/Apache_HTTP_Server "Apache HTTP Server"), [Internet Information Services](https://ru.wikipedia.org/wiki/Internet_Information_Services "Internet Information Services") (IIS), [nginx](https://ru.wikipedia.org/wiki/Nginx "Nginx"), [LiteSpeed Web Server](https://ru.wikipedia.org/w/index.php?title=LiteSpeed_Web_Server&action=edit&redlink=1 "LiteSpeed Web Server (страница отсутствует)")[[en]](https://en.wikipedia.org/wiki/LiteSpeed_Web_Server "en:LiteSpeed Web Server") (LSWS), [Google Web Server](https://ru.wikipedia.org/wiki/Google_Web_Server "Google Web Server"), [lighttpd](https://ru.wikipedia.org/wiki/Lighttpd "Lighttpd").

### Прокси-серверы

См. также: [Список веб-серверов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B2%D0%B5%D0%B1-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%B2 "Список веб-серверов")

Основные реализации: [Squid](https://ru.wikipedia.org/wiki/Squid "Squid"), [UserGate](https://ru.wikipedia.org/wiki/UserGate "UserGate"), [Multiproxy](https://ru.wikipedia.org/w/index.php?title=Multiproxy&action=edit&redlink=1 "Multiproxy (страница отсутствует)"), [Naviscope](https://ru.wikipedia.org/w/index.php?title=Naviscope&action=edit&redlink=1 "Naviscope (страница отсутствует)"), [nginx](https://ru.wikipedia.org/wiki/Nginx "Nginx").

## Структура_HTTP-сообщения

Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:

1.  Стартовая строка ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Starting line) — определяет тип сообщения;
2.  Заголовки ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
3.  Тело сообщения ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.

Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок _Host_.

### Стартовая_строка

Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:
`GET URI` — для версии протокола 0.9;
`Метод URI HTTP/Версия` — для остальных версий.
Здесь:
-   Метод ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод `GET`, список методов для версии 1.1 представлен ниже.
-   [URI](https://ru.wikipedia.org/wiki/URI "URI") определяет путь к запрашиваемому документу.
-   Версия ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Version) — пара разделённых точкой [цифр](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%B0%D0%B1%D1%81%D0%BA%D0%B8%D0%B5_%D1%86%D0%B8%D1%84%D1%80%D1%8B "Арабские цифры"). Например: `1.0`.
Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):
```http
GET /wiki/HTTP HTTP/1.0
Host: ru.wikipedia.org
```
Стартовая строка ответа сервера имеет следующий формат: `HTTP/Версия КодСостояния Пояснение`, где:
-   Версия — пара разделённых точкой цифр, как в запросе;
-   Код состояния ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Status Code) — три цифры. По [коду состояния](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0#Взаимодействие_с_веб-сервером_(HTTP) "Код ответа") определяется дальнейшее содержимое сообщения и поведение клиента;
-   Пояснение ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.
Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:
```http
HTTP/1.0 200 OK
```
### Методы

Метод HTTP ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.

Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус `501` (Not Implemented). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом `405` (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок `Allow` со списком поддерживаемых методов.

Кроме методов `GET` и `HEAD`, часто применяется метод `POST`.

#### OPTIONS

Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок [Allow](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#Allow "Список заголовков HTTP") со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.

Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.

Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «`*`». Запросы «`OPTIONS * HTTP/1.1`» могут также применяться для проверки работоспособности сервера (аналогично «[пингованию](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D0%BD%D0%B3 "Пинг")») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.

Результат выполнения этого метода не [кэшируется](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Кэширование").

#### GET

Используется для запроса содержимого указанного ресурса. С помощью метода `GET` можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.

Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «`?`»:  
`GET /path/resource?param1=value1&param2=value2 HTTP/1.1`

Согласно стандарту HTTP, запросы типа `GET` считаются [идемпотентными](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C "Идемпотентность")[[2]](https://ru.wikipedia.org/wiki/HTTP#cite_note-http-spec-methods-2)

Кроме обычного метода `GET`, различают ещё

-   [Условный `GET`](https://ru.wikipedia.org/wiki/HTTP#Условные_GET "HTTP") — содержит заголовки `If-Modified-Since`, `If-Match`, `If-Range` и подобные;
-   [Частичный `GET`](https://ru.wikipedia.org/wiki/HTTP#Частичные_GET "HTTP") — содержит в запросе `Range`.

Порядок выполнения подобных запросов определён стандартами отдельно.

#### HEAD

Аналогичен методу `GET`, за исключением того, что в ответе сервера отсутствует тело. Запрос `HEAD` обычно применяется для извлечения [метаданных](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5 "Метаданные"), проверки наличия ресурса ([валидация](https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F "Валидация") URL) и чтобы узнать, не изменился ли он с момента последнего обращения.

Заголовки ответа могут кэшироваться. При несовпадении [метаданных](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5 "Метаданные") ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.

#### POST

Основная статья: **[POST (HTTP)](https://ru.wikipedia.org/wiki/POST_(HTTP) "POST (HTTP)")**

Применяется для передачи пользовательских данных заданному ресурсу. Например, в [блогах](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%B3 "Блог") посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом [POST](https://ru.wikipedia.org/wiki/POST_(HTTP) "POST (HTTP)") и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода `POST` обычно загружаются файлы на сервер.

В отличие от метода `GET`, метод `POST` не считается идемпотентным[[2]](https://ru.wikipedia.org/wiki/HTTP#cite_note-http-spec-methods-2), то есть многократное повторение одних и тех же запросов `POST` может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).

При результате выполнения `200` (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ `201` (Created) с указанием [URI](https://ru.wikipedia.org/wiki/URI "URI") нового ресурса в заголовке `Location`.

Сообщение ответа сервера на выполнение метода `POST` не кэшируется.

#### PUT

Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус `201` (Created). Если же ресурс был изменён, то сервер возвращает `200` (Ok) или `204` (No Content). Сервер не должен игнорировать некорректные заголовки `Content-*`, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки `501` (Not Implemented).

Фундаментальное различие методов `POST` и `PUT` заключается в понимании предназначений URI ресурсов. Метод `POST` предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя `PUT`, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.

Сообщения ответов сервера на метод `PUT` не кэшируются.

#### PATCH

Аналогично PUT, но применяется только к фрагменту ресурса.

#### DELETE

Удаляет указанный ресурс.

#### TRACE

Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.

#### CONNECT

Преобразует соединение запроса в прозрачный [TCP/IP](https://ru.wikipedia.org/wiki/TCP/IP "TCP/IP")-туннель, обычно чтобы содействовать установлению защищённого [SSL](https://ru.wikipedia.org/wiki/SSL "SSL")-соединения через нешифрованный [прокси](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80 "Прокси-сервер").

### Коды_состояния

Основная статья: **[Список кодов состояния HTTP](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP "Список кодов состояния HTTP")**

Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр[[3]](https://ru.wikipedia.org/wiki/HTTP#cite_note-3digits-3). Первая цифра указывает на класс состояния. За [кодом ответа](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0#Взаимодействие_с_веб-сервером_(HTTP) "Код ответа") обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:

201 Webpage Created
403 Access allowed only for registered users
507 Insufficient Storage

Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах [RFC](https://ru.wikipedia.org/wiki/RFC "RFC"). Введение новых кодов должно производиться только после согласования с [IETF](https://ru.wikipedia.org/wiki/IETF "IETF"). Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.

В настоящее время выделено пять классов кодов состояния.

| Код | Класс | Назначение |
|-----|--------|-----------|
|[`1xx`](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#1xx "Список кодов состояния HTTP") | [Информационный](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#1xx "Список кодов состояния HTTP") | (англ. **informational**) Информирование о процессе передачи. |
| [`2xx`](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#2xx "Список кодов состояния HTTP") | [Успех](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#2xx "Список кодов состояния HTTP") | (англ. **Success**) Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.| 
|[`3xx`](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#3xx "Список кодов состояния HTTP") | [Перенаправление](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#3xx "Список кодов состояния HTTP") | (англ. **Redirection**) Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов [301](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#301 "Список кодов состояния HTTP"), [302](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#302 "Список кодов состояния HTTP"), [303](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#303 "Список кодов состояния HTTP"), [305](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#305 "Список кодов состояния HTTP") и [307](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#307 "Список кодов состояния HTTP") относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке `Location`. При этом допускается использование фрагментов в целевом URI. | 
| [`4xx`](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#4xx "Список кодов состояния HTTP") | [Ошибка клиента](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#4xx "Список кодов состояния HTTP") | (англ. **Client Error**) Указание ошибок со стороны клиента. При использовании всех методов, кроме `HEAD`, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя. | 
| [`5xx`](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#5xx "Список кодов состояния HTTP") | [Ошибка сервера](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#5xx "Список кодов состояния HTTP") | (англ. **Server Error**) Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода `HEAD`, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю. | 


### Заголовки

Основные статьи: **[Заголовки HTTP](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP "Заголовки HTTP")** и **[Список заголовков HTTP](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP "Список заголовков HTTP")**

Заголовки HTTP ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. [RFC 822](https://tools.ietf.org/html/rfc822)). Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Примеры заголовков:
```http
Server: Apache/2.2.11 (Win32) PHP/5.3.0
Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT
Content-Type: text/plain; charset=windows-1251
Content-Language: ru
```
В примере выше каждая строка представляет собой один заголовок. При этом то, что находится до двоеточия, называется именем ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") name), а что после него — значением ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") value).

Все заголовки разделяются на четыре основных группы:

1.  [General Headers](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#Основные_заголовки "Список заголовков HTTP") («Основные заголовки») — могут включаться в любое сообщение клиента и сервера;
2.  [Request Headers](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#Заголовки_запроса "Список заголовков HTTP") («Заголовки запроса») — используются только в запросах клиента;
3.  [Response Headers](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#Заголовки_ответа "Список заголовков HTTP") («Заголовки ответа») — только для ответов от сервера;
4.  [Entity Headers](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#Заголовки_сущности "Список заголовков HTTP") («Заголовки сущности») — сопровождают каждую сущность сообщения.

Именно в таком порядке рекомендуется посылать заголовки получателю.

Все необходимые для функционирования HTTP заголовки описаны в основных [RFC](https://ru.wikipedia.org/wiki/RFC "RFC"). Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «`X-`» для избежания конфликта имён с возможно существующими. Например, как в заголовках `X-Powered-By` или `X-Cache`. Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить `Ms-Echo-Request` и `Ms-Echo-Reply`, введённые корпорацией Microsoft для расширения [WebDAV](https://ru.wikipedia.org/wiki/WebDAV "WebDAV").

### Тело_сообщения

Тело HTTP-сообщения (`message-body`), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (`entity-body`) только в том случае, когда применяется кодирование передачи, что указывается полем заголовка `Transfer-Encoding`.
```http
message-body = entity-body
| <entity-body закодировано согласно
Transfer-Encoding>
```
Поле `Transfer-Encoding` должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле `Transfer-Encoding` — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов.

Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.

Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка `Content-Length` или `Transfer-Encoding`. Тело сообщения может быть добавлено в запрос, только когда метод запроса допускает тело объекта.

Включается или не включается тело сообщения в сообщение ответа — зависит как от метода запроса, так и от кода состояния ответа. Все ответы на запрос с методом `HEAD` не должны включать тело сообщения, даже если присутствуют поля заголовка объекта (`entity-header`), заставляющие поверить в присутствие объекта. Никакие ответы с кодами состояния `1xx` (Информационные), `204` (Нет содержимого, No Content), и `304` (Не модифицирован, Not Modified) не должны содержать тела сообщения. Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.

## Примеры_диалогов_HTTP

Обычный GET-запрос[[показать]](javascript:)
Перенаправления[[показать]](javascript:)
Докачка и фрагментарное скачивание[[показать]](javascript:)
_См. также [частичные GET](https://ru.wikipedia.org/wiki/HTTP#Частичные_GET "HTTP"), [байтовые диапазоны](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP#Байтовые_диапазоны "Заголовки HTTP"), [ответ 206](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#206 "Список кодов состояния HTTP"), [ответ 416](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP#416 "Список кодов состояния HTTP")._

## Основные_механизмы_протокола

### Частичные_GET
HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные `GET`; возможность их выполнения необязательна (но желательна) для серверов. Частичные `GET` в основном используются для [докачки файлов](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80_%D0%B7%D0%B0%D0%BA%D0%B0%D1%87%D0%B5%D0%BA "Менеджер закачек") и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.

Для получения фрагмента клиент посылает серверу запрос с заголовком `Range`, указывая в нём необходимые [байтовые диапазоны](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP#Байтовые_диапазоны "Заголовки HTTP"). Если сервер не понимает частичные запросы (игнорирует заголовок `Range`), то он вернёт всё содержимое со статусом `[200](https://ru.wikipedia.org/wiki/HTTP_200 "HTTP 200")`, как и при обычном `GET`. В случае успешного выполнения сервер возвращает вместо кода `200` ответ со статусом `206` (Partial Content), включая в ответ заголовок `Content-Range`. Сами фрагменты могут быть переданы двумя способами:

-   В ответе помещается заголовок `Content-Range` с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом `Content-Length` должен соответствовать суммарному объёму всего тела;
-   Сервер указывает медиатип `multipart/byteranges` для основного содержимого и передаёт фрагменты, указывая соответствующий `Content-Range` для каждого элемента (см. также «Множественное содержимое»[[⇨]](https://ru.wikipedia.org/wiki/HTTP#Множественное_содержимое)).

### Условные_GET

Метод `GET` изменяется на «условный `GET`», если сообщение запроса включает в себя поле заголовка `If-Modified-Since`. В ответ на «условный `GET`» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке `If-Modified-Since`. Алгоритм определения этого включает в себя следующие случаи:

-   Если статус ответа на запрос будет отличаться от «200 OK» или дата, указанная в поле заголовка «If-Modified-Since», некорректна, ответ будет идентичен ответу на обычный запрос GET.
-   Если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос GET.
-   Если ресурс не изменялся после указанной даты, сервер вернет статус «304 Not Modified».

Использование метода «условный GET» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.

### Согласование содержимого

Согласование содержимого ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Content Negotiation) — механизм автоматического определения необходимого ресурса при наличии нескольких разнотипных версий документа. Субъектами согласования могут быть не только ресурсы сервера, но и возвращаемые страницы с сообщениями об ошибках ([403](https://ru.wikipedia.org/wiki/HTTP_403 "HTTP 403"), [404](https://ru.wikipedia.org/wiki/HTTP_404 "HTTP 404") и т. п.).

Различают два основных типа согласований:

-   Управляемое сервером ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") server-driven).
-   Управляемое клиентом ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") agent-driven).

Одновременно могут быть использованы оба типа или каждый из них по отдельности.

В основной спецификации по протоколу ([RFC 2616](https://tools.ietf.org/html/rfc2616)) также выделяется так называемое прозрачное согласование ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") transparent negotiation) как предпочтительный вариант комбинирования обоих типов. Последний механизм не следует путать с независимой технологией Transparent Content Negotiation (TCN, «Прозрачное согласование содержимого», см. [RFC 2295](https://tools.ietf.org/html/rfc2295)), которая не является частью протокола HTTP, но может использоваться с ним. У обоих существенное различие в принципе работы и самом значении слова «прозрачное» (transparent). В спецификации по HTTP под прозрачностью подразумевается, что процесс не заметен для клиента и сервера, а в технологии TCN прозрачность означает доступность полного списка вариантов ресурса для всех участников процесса доставки данных.

#### Управляемое сервером

При наличии нескольких версий ресурса сервер может анализировать заголовки запроса клиента, чтобы выдать, по его мнению, наиболее подходящую. В основном анализируются заголовки `Accept`, `Accept-Charset`, `Accept-Encoding`, `Accept-Languages` и `[User-Agent](https://ru.wikipedia.org/wiki/User_Agent "User Agent")`. Серверу желательно включать в ответ заголовок `Vary` с указанием параметров, по которым различается содержимое по запрашиваемому URI.

Географическое положение клиента можно определить по удалённому [IP-адресу](https://ru.wikipedia.org/wiki/IP-%D0%B0%D0%B4%D1%80%D0%B5%D1%81 "IP-адрес"). Это возможно за счёт того что IP-адреса, как и [доменные имена](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D0%B8%D0%BC%D1%8F "Доменное имя"), регистрируются на конкретного человека или организацию. При регистрации указывается регион, в котором будет использоваться желаемое адресное пространство. Эти данные общедоступны, и в Интернете можно найти соответствующие свободно распространяемые базы данных и готовые программные модули для работы с ними (следует ориентироваться на ключевые слова «Geo IP»).

Следует помнить что такой метод способен определить местоположение максимум с точностью до города (отсюда определяется и страна). При этом информация актуальна только на момент регистрации адресного пространства. Например, если московский провайдер зарегистрирует диапазон адресов с указанием Москвы и начнёт предоставлять доступ клиентам из ближайшего Подмосковья, то его абоненты могут на некоторых сайтах наблюдать, что они из Москвы, а не из [Красногорска](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE%D0%B3%D0%BE%D1%80%D1%81%D0%BA "Красногорск") или [Дзержинского](https://ru.wikipedia.org/wiki/%D0%94%D0%B7%D0%B5%D1%80%D0%B6%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_(%D0%B3%D0%BE%D1%80%D0%BE%D0%B4) "Дзержинский (город)").

Управляемое сервером согласование имеет несколько недостатков:

-   Сервер только предполагает, какой вариант наиболее предпочтителен для конечного пользователя, но не может знать точно, что именно нужно в данный момент (например, версия на русском языке или английском).
-   Заголовков группы Accept передаётся много, а ресурсов с несколькими вариантами — мало. Из-за этого оборудование испытывает избыточную нагрузку.
-   Общему кэшу создаётся ограничение возможности выдавать один и тот же ответ на идентичные запросы от разных пользователей.
-   Передача заголовков Accept также может раскрывать некоторые сведения о его предпочтениях, таких как используемые языки, браузер, кодировка.

#### Управляемое клиентом

В данном случае тип содержимого определяется только на стороне клиента. Для этого сервер возвращает в ответе с кодом состояния `300` (Multiple Choices) или `406` (Not Acceptable) список вариантов, среди которых пользователь выбирает подходящий. Управляемое клиентом согласование хорошо, когда содержимое различается по самым частым параметрам (например, по языку и кодировке) и используется публичный кэш.

Основной недостаток — лишняя нагрузка, так как приходится делать дополнительный запрос, чтобы получить нужное содержимое.

#### Прозрачное согласование

Данное согласование полностью прозрачно для клиента и сервера. В данном случае используется общий кэш, в котором содержится список вариантов, как для управляемого клиентом согласования. Если кэш понимает все эти варианты, то он сам делает выбор, как при управляемом сервером согласовании. Это снижает нагрузки с исходного сервера и исключает дополнительный запрос со стороны клиента.

В основной спецификации по протоколу HTTP механизм прозрачного согласования подробно не описан.

### Множественное содержимое

Основная статья: **[MIME](https://ru.wikipedia.org/wiki/MIME "MIME")**

Протокол HTTP поддерживает передачу нескольких сущностей в пределах одного сообщения. Причём сущности могут передаваться не только в виде одноуровневой последовательности, но и в виде [иерархии](https://ru.wikipedia.org/wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0 "Иерархическая структура") с вложением элементов друг в друга. Для обозначения множественного содержимого используются медиатипы `multipart/*`. Работа с такими типами осуществляется по общим правилам, описанным в [RFC 2046](https://tools.ietf.org/html/rfc2046) (если иное не определено конкретным медиатипом). Если получателю не известно как работать с типом, то он обрабатывает его так же, как `multipart/mixed`.

Параметр boundary означает разделитель между различными типами передаваемых сообщений. Например, передаваемый из формы параметр DestAddress передаёт значение адреса e-mail, а следующий за ним элемент AttachedFile1 отправляет двоичное содержимое изображения формата .jpg

Со стороны сервера сообщения со множественным содержимым могут посылаться в ответ на [частичные `GET`](https://ru.wikipedia.org/wiki/HTTP#Частичные_GET "HTTP") при запросе нескольких фрагментов ресурса. В этом случае используется медиатип `multipart/byteranges`.

Со стороны клиента при отправке [HTML](https://ru.wikipedia.org/wiki/HTML "HTML")-формы чаще всего пользуются методом `POST`. Типичный пример: страницы отправки [электронных писем](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D1%87%D1%82%D0%B0 "Электронная почта") со вложенными файлами. При отправке такого письма браузер формирует сообщение типа `multipart/form-data`, интегрируя в него как отдельные части, введённые пользователем, тему письма, адрес получателя, сам текст и вложенные файлы:
```http
POST /send-message.html HTTP/1.1
Host: mail.example.com
Referer: http://mail.example.com/send-message.html
User-Agent: BrowserForDummies/4.67b
Content-Type: multipart/form-data; boundary="Asrf456BGe4h"
Content-Length: _(суммарный объём, включая дочерние заголовки)_
Connection: keep-alive
Keep-Alive: 300
_(пустая строка)_
_(отсутствующая преамбула)_
--Asrf456BGe4h
Content-Disposition: form-data; name="DestAddress"
_(пустая строка)_
brutal-vasya@example.com
--Asrf456BGe4h
Content-Disposition: form-data; name="MessageTitle"
_(пустая строка)_
Я негодую
--Asrf456BGe4h
Content-Disposition: form-data; name="MessageText"
_(пустая строка)_
Привет, Василий! Твой ручной лев, которого ты оставил
у меня на прошлой неделе, разодрал весь мой диван.
Пожалуйста, забери его скорее!
Во вложении две фотки с последствиями.
--Asrf456BGe4h
Content-Disposition: form-data; name="AttachedFile1"; filename="horror-photo-1.jpg"
Content-Type: image/jpeg
_(пустая строка)_
_(двоичное содержимое первой фотографии)_
--Asrf456BGe4h
Content-Disposition: form-data; name="AttachedFile2"; filename="horror-photo-2.jpg"
Content-Type: image/jpeg
_(пустая строка)_
_(двоичное содержимое второй фотографии)_
--Asrf456BGe4h--
_(отсутствующий эпилог)_
```
В примере в заголовках `Content-Disposition` параметр `name` соответствует атрибуту `name` в HTML-тегах `<INPUT>` и `<TEXTAREA>`. Параметр `filename` равен исходному имени файла на компьютере пользователя. Более подробная информация о формировании HTML-форм и вложении файлов в [RFC 1867](https://tools.ietf.org/html/rfc1867).

_____________
#### Links
http://www.webcorp.ru/page/php_post_get.html
[видос примером через telnet(curl)](https://www.youtube.com/watch?v=C_QZtajkDf0&list=PLwWxlJniY3NxOfcr7d2uhwXKlB_fyY8wK&index=2)