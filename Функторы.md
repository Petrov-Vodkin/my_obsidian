2021-09-30 15:14
#tag
# Функторы
Функторы – это объекты классов, которые можно выполнять как функции.
Например, создадим класс счетчик:
```py
class Counter:
    def __init__(self):
        self.__counter = 0
c1 = Counter()			# И далее, положим, что мы хотим вызывать его экземпляр: 
c1() 					# как функцию, то есть:

```
Для этого нужно выполнить перегрузку оператора () с помощью реализации метода `__call__`. Пусть он у нас будет таким:
```py
class Counter:
    def __init__(self):
        self.__counter = 0
	def __call__(self, *args, **kwargs):
		self.__counter += 1
		print( self.__counter )
		return self.__counter
```
Теперь, при каждом вызове этого класса в виде функции, мы будем попадать в метод call и увеличивать счетчик на 1:

Также можно добавить еще один экземпляр класса, который будет работать совершенно независимо от первого:

Этот довольно простой пример показывает общий принцип реализации функторов. Давайте немного усложним задачу и построим функтор, который бы убирал в начале и конце строки заданные символы. Для этого объявим вот такой класс:
```py
class StripChars:
    def __init__(self, chars):
        self.__chars = chars
 
    def __call__(self, *args, **kwargs):
        if not isinstance(args[0], str):
            raise ValueError("Аргумент должен быть строкой")
 
        return args[0].strip(self.__chars)
# И вызовем его как функцию:
s1 = StripChars("?:!.; ")
print( s1(" Hello World! ") )

```
На выходе получаем строку с удаленными символами, перечисленные в инициализаторе. Но это опять же лишь пример функтора в виде класса. Если такая (подобная) задача встречается на практике, то ее, как правило, реализуют через замыкания, то есть, создают функцию с определением внутри нее еще одной функции:
```py
def StripChars(chars):
    def stringStrip(string):
        if not isinstance(string, str):
            raise ValueError("Аргумент должен быть строкой")
 
        return string.strip(chars)
    return stringStrip

# И, далее, следует аналогичный вызов:
s1 = StripChars("?:!.; ")
print( s1(" Hello World! ") )
```
Только теперь переменная s1 ссылается не на экземпляр класса, а на функцию stringStrip, которая возвращается функцией StripChars. Причем, в момент ее вызова создается контекст выполнения данной функции, фактически новый объект, и мы ссылаемся на функцию внутри этого объекта:

![](https://proproprogs.ru/htm/python_oop/files/funktory.files/image001.jpg)

Сама же внутренняя функция stringStrip имеет ссылку на внешний контекст, то есть, на объект, созданный StipChars. Поэтому сборщик мусора не уничтожает его.

Из этой иллюстрации хорошо видно, что если создать еще один такой же объект:
```py
s2 = StripChars("?:!.; ")
print( s2(" Hello? ") )
```
то они будут работать совершенно независимо, т.к. функция stringStrip также динамически создается внутри контекста выполнения функции StipChars. Если, например, вывести их id:
```py
print( id(s1), id(s2), sep="n")
```
то они будут совершенно разными.

Итак, из всего этого можно заключить, что если нам нужно выполнить какие-то простые операции, то лучше использовать замыкания. Но, если требуется реализовать более сложный механизм, предполагающий элементы наследования и полиморфизма, то следует задуматься об использовании функторов.
_____________
#### Links
https://proproprogs.ru/python_oop/funktory