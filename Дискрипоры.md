2022-02-08 15:44
[doc_ru](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovyj-obzor-deskriptora-klassa/) | [habr](https://habr.com/ru/post/122082/)
# Дискрипоры
Дескриптор — это атрибут объекта со связанным поведением, т.е. такой, чьё поведение при доступе переопределяется методами протокола дескриптора. Эти методы: `__get__`, `__set__` и `__delete__`. Если хотя бы один из этих методов определён для объекта, то он становится дескриптором (Дескриптор - это любой объект, который определяет методы `__get__()`, `__set__()` или `__delete__()`)
Опционально дескрипторы могут иметь метод `__set_name__()` - используется только в тех случаях, когда дескриптору необходимо знать либо класс, в котором он был создан, либо имя переменной класса, которой он был присвоен. 
Это классы, которые позволяют вам делать управляемыми свойства в другом классе. 

### non-date
дескриптор имеет только метод `__get__()`
```python
from random import choice  
  
# EX non-date ДИСКРИПТОРА  
class Choice:  
    def __init__(self, *args):  
        self._choice = args  
  
    def __get__(self, instance, owner):  
        return choice(self._choice)  
  
  
class Game:  
    dice = Choice([1, 2, 3, 4, 5, 6])  # игра кости (1н кубик)
    flip = Choice('Камень', "Ножницы", "Бумага")  
  
  
g = Game()
g.dice		# от 1го до 6ти
g.flip		# 'Камень' or "Ножницы" or "Бумага"
```

Дескрипторы данных и не данных отличаются в том, как будет изменено поведение поиска, если в словаре объекта уже есть запись с таким же именем как у дескриптора. Если попадается дескриптор данных, то он вызывается раньше, чем запись из словаря объекта. Если в такой же ситуации окажется дескриптор не данных, то запись из словаря объекта имеет преимущество перед этим дескриптором.

### Дескриптор данных
включают методы `__set__()` и `__delete__()`
```python
class RevealAccess(object):
    """Дескриптор данных, который устанавливает и возвращает значения,
       и печатает сообщение о том, что к атрибуту был доступ.
    """

    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name
    
    def __get__(self, obj, objtype):
        print 'Получаю', self.name
        return self.val

    def __set__(self, obj, val):
        print 'Обновляю' , self.name
        self.val = val

class MyClass(object):
    x = RevealAccess(10, 'var "x"')
    y = 5

m = MyClass()
m.x				# Получаю var "x" 10
m.x = 20		# Обновляю var "x"
m.x				# Получаю var "x" 20
m.y				# 5
```
Алгоритм реализуется с помощью:
- для объектов  `object.__getattribute__`, который преобразует запись `b.x` в `type(b).__dict__['x'].__get__(b, type(b))`
- для классов `type.__getattribute__`, который преобразует запись `B.x` в `B.__dict__['x'].__get__(None, B)`

```python
def __getattribute__(self, key):
    "Эмуляция type_getattro() в Objects/typeobject.c"
    v = object.__getattribute__(self, key)
    if hasattr(v, '__get__'):
        return v.__get__(None, self)
    return v
```

  
Важные части, которые следует запомнить:

-   дескрипторы вызываются с помощью метода `__getattribute__`
-   переопределение `__getattribute__` прекратит автоматический вызов дескрипторов
-   `__getattribute__` доступен только внутри классов и объектов нового стиля
-   `object.__getattribute__` и `type.__getattribute__` делают разные вызовы к `__get__`
-   дескрипторы данных всегда имеют преимущество перед переменными объекта
-   дескрипторы не данных могут потерять преимущество из-за переменных объекта
Чтобы создать дескриптор данных только для чтения, определите и `__get__`, и `__set__`, и сделайте так, чтобы `__set__` выбрасывал исключение `AttributeError`. Определения метода `__set__` и выбрасывания исключения достаточно, чтобы этот дескриптор считался дескриптором данных.
Дескриптор можно вызвать напрямую через его метод. Например, `d.__get__(obj)`.  
  
Однако, наиболее частый вариант вызова дескриптора — это автоматический вызов во время доступа к атрибуту. Например, `obj.d` ищет `d` в словаре `obj`. Если `d` определяет метод `__get__`, то будет вызван `d.__get__(obj)`
_____________
#### Links
[[ООП]]