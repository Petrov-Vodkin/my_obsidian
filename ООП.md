2020-12-23 17:09
#ооп #объектно
# [ООП](https://habr.com/ru/post/479640/)

#### Базовые принципы ООП
* **Полиморфизм** — возможность работы с совершенно разными объектами языка Python единым образом;
* **Наследование** — способность объекта или класса базироваться на другомобъекте или классе. Это главный механизм для повторного использованиякода. Наследственное отношение классов четко определяет их иерархию;
* **Инкапсуляция** — размещение одного объекта или класса внутри другого дляразграничения доступа к ним.
* (**Абстракция** — отделение концепции от ее экземпляра;)

#### [[Магические методы]] |  [[Шаблоны ООП Py]] | [[Дискрипоры]]
#### Полезные функции
**`Z.mro()`** возвращает нам список классов ровно в том порядке, в котором Python будет искать методы в иерархии классов пока не найдет нужный или не выдаст ошибку. Example: `C -> A -> B -> objec`

**`super()`**
```py
super(type, object-or-type)
# type - необязательно, тип, от которого начинается поиск объекта-посредника
# object-or-type - необязательно, тип или объект, определяет порядок разрешения метода для поиска
```
В версиях Python 3.x мы можем использовать super без передачи двух вышеуказанных параметров. Посмотрите на приведенный ниже фрагмент кода. 
```py
class C(B):
	def method(self, arg): 
		super().method(arg)  
```

#### **`@staticmethod`**
— это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.
```py 
# можем получить доступ к статическому методу класса без создания экземпляра
Myclass.name_of_staticmethod()
```
**`@staticmethod`** используется, когда мы хотим вернуть одно и то же, независимо от вызываемого дочернего класса.
####  **`@classmethod`**
— это метод класса, имеющий доступ ко всем атрибутам класса, но не к атрибутам экземпляра. Этот метод, который привязан к классу, а не к экземпляру класса.
```py
from datetime import date
		# EX создание альтернативного инициализатора(__init__)
# random Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
	# альтернативный инициализатор(__init__)
    @classmethod
    def fromBirthYear(cls, name, birthYear):			# cls - пердаём класс
        return cls(name, date.today().year - birthYear)	# возвращаем Экземпляр класса с альтернативным age

    def display(self):
        print(self.name + "'s age is: " + str(self.age))

person = Person('Adam', 19)
person.display()		# Adam's age is: 19

person1 = Person.fromBirthYear('John',  1985)
person1.display()		# John's age is: 31
```
**`@classmethod`** используется в суперклассе для определения того, как метод должен вести себя, когда он вызывается разными дочерними классами. 
#### **`@property`** декоратор свойств 
```python
class Som:  
    def __init__(self, name, surname):  
        self._name = name  
        self._surname = surname  
        self._full_name = None  
  
 # возможность обращаться к методу класса как к атрибуту  
	@property  
	def name(self):  
        return self._name  
  
    @name.setter # задаёт значения атрибутов  
	def name(self, vol):  
        self._name = vol  
        self._full_name = None  # при смене имени "обнуляем" полное имя
  
	@property  
	def surname(self):  
        return self._surname  
  
    @surname.setter # задаёт значения атрибутов  
	def surname(self, vol):  
        self._surname = vol  
        self._full_name = None  # при смене _ "обнуляем" полное имя
  
	@property  
 	def full_name(self):  
		if self._full_name is None:  
			self._full_name = f'{self._name} {self._surname}' 
		return self._full_name
		  
  
c = Som('Das', "Avto")	
```

#### Не повторяйся (Don’t repeat yourself — DRY)
Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.
#### Принцип единственной обязанности
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.
#### Принцип открытости/закрытости
Программные сущности должны быть открыты для расширения, но закрыты для изменений.
#### Принцип подстановки Барбары Лисков
Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.
#### Принцип разделения интерфейсов
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.
#### Принцип инверсии зависимостей
Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

https://habr.com/ru/hub/oop/


#### Links
[[Python]]

