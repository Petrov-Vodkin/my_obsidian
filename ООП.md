2020-12-23 17:09
#ооп #объектно
# [ООП](https://habr.com/ru/post/479640/)

#### Базовые принципы ООП
* **Полиморфизм** — возможность работы с совершенно разными объектами языка Python единым образом;
* **Наследование** — способность объекта или класса базироваться на другомобъекте или классе. Это главный механизм для повторного использованиякода. Наследственное отношение классов четко определяет их иерархию;
* **Инкапсуляция** — размещение одного объекта или класса внутри другого дляразграничения доступа к ним.
* (**Абстракция** — отделение концепции от ее экземпляра;)

#### [[Магические методы]]
#### [[Шаблоны ООП Py]]
#### **`@staticmethod`**
— это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.
```py 
# можем получить доступ к статическому методу класса без создания экземпляра
Myclass.name_of_staticmethod()
```
**`@staticmethod`** используется, когда мы хотим вернуть одно и то же, независимо от вызываемого дочернего класса.
####  **`@classmethod`**
— это метод класса, имеющий доступ ко всем атрибутам класса, но не к атрибутам экземпляра. Этот метод, который привязан к классу, а не к экземпляру класса.
```py
class MyClass:
    @classmethod
    def name_classmethod(cls): # ПЕРЕДВЁМ ПАРАМЕТР cls !!!!!
        print('Class method called')
# его можно вызывать без создания экземпляра класса, но его определение следует за подклассом, а не за родительским классом, через наследование.
MyClass.name_classmethod()	
# метод можно переопределить дочерними классами
```
**`@classmethod`** используется в суперклассе для определения того, как метод должен вести себя, когда он вызывается разными дочерними классами. 
#### **`@property`** декоратор свойств 
```py
class Som:
	def __init__(self, name, marks):
		self.name = name 
		self.marks = marks  
	# возможность обращаться к методу класса как к атрибуту (не нужно явно вызывать st.gotmarks() а st.gotmarks)	
	@property 				
	def gotmarks(self): 
		return self.name + ' obtained ' + self.marks + ' marks' 
	# задаёт значения атрибутов	
	@gotmarks.setter 
		def gotmarks(self, sentence): name, rand, marks = sentence.split(' ') 
		self.name = name 
		self.marks = marks  

st = Student("Jaki", "25") 
print(st.name) print(st.marks) print(st.gotmarks)  
st.gotmarks = 'Golam obtained 36'  
```
#### Не повторяйся (Don’t repeat yourself — DRY)
Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.
#### Принцип единственной обязанности
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.
#### Принцип открытости/закрытости
Программные сущности должны быть открыты для расширения, но закрыты для изменений.
#### Принцип подстановки Барбары Лисков
Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.
#### Принцип разделения интерфейсов
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.
#### Принцип инверсии зависимостей
Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

https://habr.com/ru/hub/oop/


#### Links
[[Python]]

