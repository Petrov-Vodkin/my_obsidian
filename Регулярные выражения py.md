2021-11-18 22:47
[docs ru](https://docs-python.ru/standart-library/modul-re-python/) | [habr](https://habr.com/ru/post/349860/)
# Регулярные выражения py
```py
\	# используется для игнорирования специального значения символа
	\A	# только с начало строки
	\b	# пустая строка начало или конец слова
			# \b\b - соо-т 1му слову 
	\B	# пустая строка НЕ начало или конец слова
	\d	# соответствует любой десятичной цифре, это то же самое, что и [0-9]
	\D	# соответствует любому нечисловому символу
	\s	# соответствует любому пробельному символу
	\S	# соответствует любому не пробельному символу
	\w	# соответствует любому буквенно-числовому символу; это то же самое, что и [a-zA-Z0-9_].
	\W	# соответствует любому не буквенно-числовому символу.

[]	# указывает на класс символов. Например: [a-z] — все буквы латинского алфавита в нижнем регистре, [a-zA-Z0-9] — все буквы в обоих регистрах плюс цифры
^	# соответствует началу текста
$	# обозначает конец текста
.	# соответствует любому символу, кроме символа новой строки 
		# 3 символа меэжу z И z:  r'z.{3}z' || r'z...z'
?	# обозначает одно или ноль вхождений
|	# означает ИЛИ (совпадение с любым из символов, разделенных им)
*	# любое количество вхождений (включая 0 вхождений)
		# указывает, что предыдущий символ может быть сопоставлен ноль и более раз, вместо одного сравнения
+	# одно и более вхождений
{}	# указывает на несколько совпадений предыдущего RE.
# `{m,n}`, где `m` и `n` — целые числа. Этот определитель означает, что здесь должно быть не менее `m` и не более `n` повторений
()	# отделяет группу в регулярном выражении


re.search(шаблон, str)	# озвращает совпадающую часть строки и останавливается сразу же, как находит первое совпадение
re.match(шаблон, str)	# ищет совпадение по заданному шаблону В НАЧАЛЕ строки
re.findall(шаблон, str)	# возвращает [ВСЕ совпадения с шаблоном]
re.compile
re.split(шаблон, str, maxsplit = 0)	# разделяет строку по заданному шаблону.
# Если шаблон найден, оставшиеся символы из строки возвращаются в виде списка
re.sub(шаблон, repl, str, count = 0, flags = 0) # «sub»==substring==подстрока
# шаблон сопоставляется с строкой, при совпадении она заменяется repl
re.subn(шаблон, repl, str, count = 0, flags = 0) # аналог re.sub + возвращает кол-во замен
re.escape(str)	# возвращает строку с обратной косой чертой `\` перед каждым не буквенно-числовым символом
# т.е экранирует буквенно-числовые символы

```
####  Flags
```py
re.match(r"(te)*?xt", "TEXT", re.IGNORECASE | re.DEBUG)
```
| Константа | Её смысл |
|---------|------------|
|`re.ASCII`| По умолчанию `\w`, `\W`, `\b`, `\B`, `\d`, `\D`, `\s`, `\S` соответствуют  все юникодные символы с соответствующим качеством.  Например, `\d` соответствуют не только арабские цифры,  но и вот такие: ٠١٢٣٤٥٦٧٨٩. `re.ASCII` ускоряет работу, если все соответствия лежат внутри ASCII. |
| `re.IGNORECASE` | Не различать заглавные и маленькие буквы.  Работает медленнее, но иногда удобно | 
| `re.MULTILINE` | Специальные символы `^` и `$` соответствуют началу и концу каждой строки
| `re.DOTALL`| По умолчанию символ `\n` конца строки не подходит под точку. С этим флагом точка — вообще любой символ
#### Группы
```py
import re
line = 'abcdef'
pattern = r'(\w)(\w)(\w)(\w+)'
print(re.sub(pattern, r'\3\2\1\4', line))
#  cbadef
```
В нашем шаблоне (pattern) есть (\w) повторённая три раза. Операция повторения () даёт нам возможность запомнить "индекс" элемента шаблона. Этот "индекс" в дальнейшем мы можем вызвать например через \1 что соответствует первому элементу группировки т.е. `\1 == 'a'`, `\2 =='b'`, `\3 == 'с'` ,`(\w+) == 'def'`  то есть остаток нашей строки.
Указывая в выводе \3\2\1\4 мы заменяем соответствующие элементы в обратном порядке:  \3\2\1 == 'cba'  то же самое 'abc' >>>'cba' и прибавляем к ним 'def' через \4.

#### EX
```py
# Выведите строки, содержащие "**cat**" в качестве подстроки хотя бы два раза
import re  
import sys  

for line in sys.stdin:  
    if re.search("(cat).*(cat)", re.escape(line.rstrip())):  
        print(line, end="")
```
```py
# посик ... состоящее из двух одинаковых частей через -
import re  

pattern = r"((\w+)-\2)"  
# r"(\b(\w+)\1\b)"    - СЛОВО(\b), состоящее из двух одинаковых частей blabla
string = "test-test chow-chow"  
duplicates = re.findall(pattern, string)  
print(duplicates)
```
```py
# поменяйтm местами 2е первые буквы в каждом слове, состоящем хотя бы из двух букв.
import re    
import sys    
  
for line in sys.stdin:    
    if re.search(r"qq", re.escape(line.rstrip())): break
    line = line.rstrip()     
    print(re.sub(r"\b(\w)(\w)", r"\2\1", line))
```
```py
# В каждой строке замените все вхождения нескольких одинаковых букв на одну букву

import re  
import sys  
  
  
for line in sys.stdin:  
    line = line.rstrip()  
    print(re.sub(r'(\w)\1+', r"\1", line))
```

_____________
#### Links
[[Str Py]]

https://pythonist.ru/regulyarnye-vyrazheniya-v-python/
[Онлайн тестер и отладчик, можно использовать для создания](https://regex101.com/)
[cheetsheet](https://www.exlab.net/files/tools/sheets/regexp/regexp.pdf)