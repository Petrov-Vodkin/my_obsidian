2021-09-15 21:11
[en doc](https://docs.scipy.org/doc/)
# NumPy
элементы массива должны иметь одинаковый тип данных
```py
import numpy as np
# элементы массива должны иметь одинаковый тип данных 
'Одномерный массив'
# np.array - формирует массив только на основе списка или кортежа
a = np.array([1, 4, 5, 8])		# создание ономерного массива (автовыбор типа данных)
a = np.array([0]*5)				# array([0, 0, 0, 0, 0])
a = np.array([1, 4, 5, 8],float)# array([1, 4, 5, 8])
a[:2] 		# срез массива == array([ 1.,  4.])
a[3] 		# 8.0
a[0] = 5.	# a == array([ 5.,  4.,  5.,  8.])
"Многомерный массив"
a = np.array([[1, 2, 3], [4, 5, 6]], float) # двумерный массив
a == array([[ 1.,  2.,  3.],
			[ 4.,  5.,  6.]])
a[0,1] # == 2.0
a[1,:] # == array([ 4.,  5.,  6.])
a[:,2] # == array([ 3.,  6.])
a[-1:, -2:] == # array([[ 5.,  6.]])

a.shape # количество строк и столбцов в матрице
a.dtype # тип переменных, хранящихся в массиве
len(a)	# длина первого измерения(кол-во строк)

a.reshape((5, 2))	# переформатирует (создает новый массив) массив в двумерный , состоящий из пяти строк и двух столбцов
a.flatten()			# переконвертировать многомерный массив в одномерный 
np.concatenate((a, b))
					# сложить массивы (def - по оси 0: ((a,b), axis=0))
c =  a.copy()		# создание копии существующего массива

a.tolist()		# преобразовать массив в список
a.tostring()	# преобразовать массив в бинарную строку
p.fromstring(a)	# преобразовать бинарную строку в массив

a.fill(0)		# заполнить массив 0
a.transpose()	# 

np.newaxis	# константа ??
```
#### Другие пути создания массивов  
```py
'arange' 		# аналогична функции range, но возвращает массив
np.arange(1, 6, 1.5)		# array([1. , 2.5, 4. , 5.5]): от 1 до 6 шаг 1.5 (в range шаг только int)
					# создать массив разделив отрезок
'linspace'	# создать массив разделив отрезок(от start до stop) на n частей
np.linspace(0, np.pi, 4)	# array([0., 1.04719755, 2.0943951 , 3.14159265])
np.logspace(start, stop, n)	# логорифмы
np.geomspace(start, stop, n)# геометроческая прогрессия

					# на основе имеющихся данных
np.copy(a)		# 
np.fromfunction(lambda x, y: x*2-y, (2,2)) 	# на основе ф-й 
# array([[ 0., -1.], [ 2.,  1.]])
np.fromiter('hello', dtype='U1')			# на основе ЛЮБОГО итерируемого объекта
# array(['h', 'e', 'l', 'l', 'o'], dtype='<U1')
np.fromiter((i for i in range(3)), dtype='int8') # array([0, 1, 2], dtype=int8)
np.fromstring('1 2 3', dtype='int16', sep=' ')# на основе строк
# sep - разделитель (сипарировать?)

'zeros и ones'	# создают новые массивы с установленной размерностью
np.ones((2,3), dtype=float)	# array([[ 1.,  1.,  1.],		 [ 1.,  1.,  1.]])
np.zeros(7, dtype=int) 		# array([0, 0, 0, 0, 0, 0, 0])

'zeros_like'	# преобразовать уже созданный массив, заполнив его нулями 
np.zeros_like(a)# array([[ 0.,  0.,  0.],       [ 0.,  0.,  0.]])
# 		# -||- единицами 
np.ones_like(a)	# array([[ 1.,  1.,  1.],       [ 1.,  1.,  1.]])

'identity'		# создать квадратную матрицу с главной диагональю, которая заполненная единицами
np.identity(4, dtype=float)
							#array([[ 1.,  0.,  0.,  0.],
							#       [ 0.,  1.,  0.,  0.],
							#       [ 0.,  0.,  1.,  0.],
							#       [ 0.,  0.,  0.,  1.]])

'eye' 			# матрица с единичками на к-атой диагонали:  
np.eye(4, k=1, dtype=float)		# k - номер диаганали
								#array([[ 0.,  1.,  0.,  0.],
								# 	    [ 0.,  0.,  1.,  0.],
								# 	    [ 0.,  0.,  0.,  1.],
								# 	    [ 0.,  0.,  0.,  0.]])
'full'			# произвольный массив размерностью 3 на 2, заполненный -1
np.full((3,2), -1) # array([[-1, -1], [-1, -1], [-1, -1]])
'tri'			# 
np.tri(3)				# 
						# array([[1., 0., 0.],
						# 	     [1., 1., 0.],
						# 	     [1., 1., 1.]])
						
'map'			# создаёт МАТРИЦУ из строки
np.mat('1 2 3 4')		# matrix([[1, 2, 3, 4]]) одномерная
np.mat('1 2; 3 4')		# matrix([[1, 2], [3, 4]]) двумерная

'diag'
np.diag([1,2,3,4])		#  array([[ 1.,  0.,  0.,  0.],
						#         [ 0.,  2.,  0.,  0.],
						#         [ 0.,  0.,  3.,  0.],
						#         [ 0.,  0.,  0.,  4.]])

```
# Математические операции над массивами
Когда для массивов мы используем стандартные математические операции, должен соблюдаться принцип: элемент--элемент. Это означает, что массивы должны быть одинакового размера во время сложения, вычитания и тому подобных операций:  
```py
a = np.array([1,2,3], float)
b = np.array([5,2,6], float)
a + b	# array([6., 4., 9.])
a – b	# array([-4., 0., -3.])
a * b	# array([5., 4., 18.])
b / a	# array([5., 1., 2.])
a % b	# array([1., 0., 3.])
b**a	# array([5., 4., 216.])
```
Для `двухмерных` массивов, `умножение остается поэлементным` и не соответствует умножению матриц.
```py
a = np.array([[1,2], [3,4]], float)
b = np.array([[2,0], [1,3]], float)
a * b	# array([[2., 0.], [3., 12.]])
```
**`При несоответствии в размере выбрасываются ошибки`**
Однако, если размерность массивов не совпадает, они будут преобразованы для выполнения математических операций. Это зачастую означает, что меньший массив будет использован несколько раз для завершения операций. Рассмотрим такой пример:  
```py
a = np.array([[1, 2], [3, 4], [5, 6]], float)
b = np.array([-1, 3], float)
a + b	# array([[ 0.,  5.], [ 2.,  7.], [ 4.,  9.]])
# массив b был преобразован в двухмерный, который соответствует размеру массива a
```
Python автоматически преобразовывает массивы в этом случае. Иногда, однако, когда преобразование играет роль, мы можем использовать константу newaxis, чтобы изменить преобразование:  
```py
a = np.zeros((2,2), float)		# array([[ 0.,  0.], [0.,  0.]])
b = np.array([-1., 3.], float)	# array([-1., 3.])
a + b 				# array([[-1.,  3.], [-1.,  3.]])
a + b[np.newaxis,:] # array([[-1.,  3.], [-1.,  3.]])
a + b[:,np.newaxis]	# array([[-1., -1.], [ 3.,  3.]])
```
#### Cтандартные математические функций
`sin`, `cos`, `tan`, `arcsin`, `arccos`, `arctan`, `sinh`, `cosh`......
```py
# применяются поэлементно к массивам: `abs`, `sign`, `sqrt`, `log`, `log10`, `exp`, `sin`, `cos`, `tan`, `arcsin`, `arccos`, `arctan`, `sinh`, `cosh`, `tanh`, `arcsinh`, `arccosh`, и `arctanh`.  
a = np.array([1, 4, 9], float)
np.sqrt(a)	# array([ 1.,  2.,  3.])
```
Функции floor, ceil и rint возвращают нижние, верхние или ближайшие (округлённое) значение:  
```py
a = np.array([1.1, 1.5, 1.9], float)
np.floor(a)	# array([ 1.,  1.,  1.])
np.ceil(a)	# array([ 2.,  2.,  2.])
np.rint(a)	# array([ 1.,  2.,  2.])
```
Также в numpy включены две важные математические константы:  
```py
np.pi	# 3.1415926535897931
np.e	# 2.7182818284590451
```
#### Перебор элементов массива
Проводить итерацию массивов можно аналогично спискам:  
```py
a = np.array([1, 4, 5], int)
for x in a:
	print x
# 1 4 5 
```
Для многомерных массивов итерация будет проводиться по первой оси, так, что каждый проход цикла будет возвращать «строку» массива:  
```py
a = np.array([[1, 2], [3, 4], [5, 6]], float)
for x in a:
	print x
#[ 1.  2.] [ 3.  4.]  5.  6.]
```
Множественное присваивание также доступно при итерации:  
```py
a = np.array([[1, 2], [3, 4], [5, 6]], float)
for (x, y) in a:
		print x * y
# 2.0 12.0 30.0
```
#### Базовые операции над массивами
```py
'Сумма \ умножение'
a = np.array([2, 4, 3], float)
# функции массива:
a.sum()	# 9.0
a.prod()# 24.0
# собственные функции numpy:  
np.sum(a) # 9.0
np.prod(a)# 24.0

'mean'	# среднее арифметическое \  вариация и девиация:  
a = np.array([2, 1, 9], float)
a.mean()# 4.0
a.var()	# 12.666666666666666
a.std()	# 3.5590260840104371

'минимум и максимум'  
a = np.array([2, 1, 9], float)
a.min()	# 1.0
a.max()	# 9.0

'argmin и argmax' # возвращают индекс минимального или максимального элемента  
a = np.array([2, 1, 9], float)
a.argmin()	# 1
a.argmax()	# 2
```
Для многомерных массивов каждая из функций может принять дополнительный аргумент axis и в зависимости от его значения выполнять функции по определенной оси, помещая результаты исполнения в массив:  
  
```зн
a = np.array([[0, 2], [3, -1], [3, 5]], float)
a.mean(axis=0)	# array([ 2.,  2.])
a.mean(axis=1)	# array([ 1.,  1.,  4.])
a.min(axis=1)	# array([ 0., -1.,  3.])
a.max(axis=0)	# array([ 3.,  5.])
```
Как и списки, массивы можно отсортировать:  
```py
a = np.array([6, 2, 5, -1, 0], float)
sorted(a)	# [-1.0, 0.0, 2.0, 5.0, 6.0]
a.sort()
a			# array([-1.,  0.,  2.,  5.,  6.])
```
Значения в массиве могут быть «сокращены», чтобы принадлежать заданному диапазону. Это тоже самое что применять min(max(x, minval), maxval) к каждому элементу x:  
```py
a = np.array([6, 2, 5, -1, 0], float)
a.clip(0, 5)	# array([ 5.,  2.,  5.,  0.,  0.])

`Уникальные элементы` # могут быть извлечены вот так:  
a = np.array([1, 1, 4, 5, 5, 5, 7], float)
np.unique(a)	# array([ 1.,  4.,  5.,  7.])

'Диагональ'			# для двухмерных массивов  
a = np.array([[1, 2], [3, 4]], float)
a.diagonal()	# array([ 1.,  4.])
```
_____________
#### Links
[Habr](https://habr.com/ru/post/352678/)