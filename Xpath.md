2021-09-28 09:45
#tag
# Xpath
**Выражения XPath**

XPath использует выражения пути для выбора отдельных узлов или набора узлов в документе XML. Эти выражения очень похожи на выражения, которые вы видите, когда работаете с традиционной файловой системой компьютера.

**Стандартные функции XPath**

XPath включает в себя более 100 встроенных функций. Есть функции для строковых и числовых значений, даты и времени, сравнения узлов и манипулирования QName, управления последовательностями, булевых значений, и многое другое.

**XPath используется в XSLT**

XPath является одним из основных элементов в стандарте XSLT. Без знания XPath вы не будете иметь возможность создавать XSLT-документы.

**XPath является рекомендацией консорциума W3C**

XPath стал рекомендацией W3C 16 ноября 1999 года. XPath был разработан для использования в XSLT, XPointer и другом программном обеспечении для разбора (парсинга) документов XML.

## 2_Терминология_ XPath

#### Узлы

В XPath существует семь видов узлов: элемент, атрибут, текст, пространство имён, инструкции обработки, комментарии и узлы документа. XML-документы обрабатываются в виде деревьев узлов. Верхний элемент дерева называется корневым элементом. Посмотрите на следующий документ XML:
```
<?xml version="1.0" encoding="UTF-8"?> <bookstore> <book> <title lang="en">Harry Potter</title> <author>J. K. Rowling</author> <year>2005</year> <price>29.99</price> </book> </bookstore>
```
Пример узлов в документе XML выше:
```
**<bookstore>** (корневой элемент) **<author>J. K. Rowling</author>** (узел) **lang="en"** (атрибут)
```
#### Атомарные значения
Атомарные значения являются узлами, не имеющие детей или родителей. Пример атомарных значений:
```
J. K. Rowling 
"en"
```
#### Элементы
Элементы – это атомарные значения или узлы.

## 3_Отношения_узлов

#### Родитель

Каждый элемент и атрибут имеет одного родителя. В следующем примере элемент «книга» (book) является родителем элементов «название» (title), «автор» (author), «год» (year) и «цена» (price):
```
<book> <title>Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book>
```
#### Потомки

Узлы элементов могут иметь ноль, один или более потомков. В следующем примере элементы «название», «автор», «год» и «цена» – они все потомки элемента книга:
```
<book> <title>Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book>
```
#### Элементы одного уровня

Это узлы, которые имеют одного и того же родителя. В следующем примере элементы «название», «автор», «год» и «цена» все являются элементами одного уровня:
```
<book> <title>Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book>
```
#### Предки

Родитель узла, родитель родителя узла и т.д. В следующем примере предки элемента «название» (title) – это элементы «книга» (book) и «книжный магазин» (bookstore):
```
<bookstore> <book> <title>Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book> </bookstore>
```
#### Потомки

Дети узла, дети детей узла и т.д. В следующем примере потомками элемента «книжный магазин» являются элементы «книга», «название», «автор», «год» и «цена»:
```
<bookstore> <book> <title>Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book> </bookstore>
```
## 4_Синтаксис_ XPath

XPath использует выражения пути для выбора узлов или множества узлов в документе XML. Узел можно выбрать, следуя пути или по шагам. Мы будем использовать следующий XML-документ в приведённых ниже примерах.
```
<?xml version="1.0" encoding="UTF-8"?> <bookstore> <book> <title lang="en">Harry Potter</title> <price>29.99</price> </book> <book> <title lang="en">Learning XML</title> <price>39.95</price> </book> </bookstore>
```
#### Выбор узлов

С помощью выражений XPath для выбора узлов в документе XML можно выбрать узел, следуя пути или шагам. Самые полезные выражения пути перечислены ниже:

| Выражение | Описание |
|-----------|----------|
| _имя_узла_ | Выбирает все узлы с именем имя_узла
| /	| Выбирает от корневого узла |
| //	|	Выбирает узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся |
|.	|Выбирает текущий узел
| .. | Выбирает родителя текущего узла
| @ | Выбирает атрибуты

В приведенной ниже таблице перечислены некоторые пути выражения и результат выполнения выражения:

| Выражение XPath |  Результат |
|-----------|-------|
|bookstore |Выбирает все узлы с именем "bookstore"
|/bookstore|Выбирает корневой элемент книжного магазина **Примечание:** Если путь начинается с косой черты (/), он всегда представляет собой абсолютный путь к элементу!
|bookstore/book | |Выбирает все элементы «книга» (book), которые являются потомками элемента «книжный магазин» (bookstore)
|//book |Выбирает все элементы «книга» независимо от того, где они находятся в документе
|bookstore//book |Выбирает все элементы «книга», которые являются потомком элемента «книжный магазин», независимо от того, где они находятся под элементом «книжный магазин»
|//@lang |Выбирает все атрибуты, которые называются "lang"

#### Предикаты

Предикаты используются для поиска специфического узла или узла, который содержит специфическое значение. Предикаты всегда обрамляются квадратными скобками. В приведённой ниже таблице перечислены некоторые выражения пути с предикатами, и результат выражения:

Выражения XPath

Результат

/bookstore/book[1]

Выбирает первый элемент «книга», который является потомком элемента «книжный магазин».

**Примечание:** В IE 5,6,7,8,9 первый узел имеет индекс [0], но в соответствии с рекомендациями W3C, это [1]. Для решения этой проблемы в IE, задаётся опция "SelectionLanguage" для XPath:

_На JavaScript: xml_.setProperty("SelectionLanguage", "XPath");

/bookstore/book[last()]

Выбирает последний элемент «книга» (book), который является дочерним элементом элемента «книжный магазин» (bookstore)

/bookstore/book[last()-1]

Выбирает предпоследний элемент «книга», который является дочерним элементом элемента «книжный магазин»

/bookstore/book[position()<3]

Выбор первых двух элементов «книга», которые являются потомками элемента «книжный магазин»

//title[@lang]

Выбирает все элементы «название» (title), которые имеют атрибут с именем "lang"

//title[@lang='en']

Выбирает все элементы «название», которые имеют атрибут «язык» со значением "en"

/bookstore/book[price>35.00]

Выбирает все элементы «книга» после элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00

/bookstore/book[price>35.00]/title

Выбирает все элементы «название» книги элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00

#### Выбор неизвестных узлов

Специальные символы XPath могут использоваться для выбора неизвестных XML узлов.

Wildcard

Описание

*

Соответствует любому узлу

@*

Соответствует узлу-атрибуту

node()

Соответствует любому узлу любого типа

В приведённой ниже таблице мы перечислили некоторые пути выражения и результаты выражений:

Выражение пути

Результат

/bookstore/*

Выбирает все дочерние узлы элемента «книжный магазин» (bookstore)

//*

Выбирает все элементы в документе

//title[@*]

Выбирает все элементы «название» (title), которые имеют по крайней мере один атрибут любого вида

#### Выбор нескольких путей

С помощью оператора | в выражениях XPath вы можете выбрать несколько путей. В таблице ниже перечислены несколько выражений путей и результаты их применения:

Выражение пути

Результат

//book/title | //book/price

Выбирает все элементы «название» (title) И «цена» (price) всех элементов «книга» (book)

//title | //price

Выбирает все элементы «название» (title) И «цена» (price) в документе

/bookstore/book/title | //price

Выбирает все элементы «название» элемента «книга» элемента «книжный магазин» И все элементы «цена» в документе

## 5_Оси_XPath

Мы будем использовать следующий XML документ далее в примере.

<?xml version="1.0" encoding="UTF-8"?> <bookstore> <book> <title lang="en">Harry Potter</title> <price>29.99</price> </book> <book> <title lang="en">Learning XML</title> <price>39.95</price> </book> </bookstore>

Оси определяют наборы узлов, относительно текущего узла.

Название оси

Результат

ancestor

Выбирает всех предков (родителей, прародителей и т.д.) текущего узла

ancestor-or-self

Выбирает всех предков (родителей, прародителей и т.д.) текущего узла и сам текущий узел

attribute

Выбирает все атрибуты текущего узла

child

Выбирает всех потомков текущего узла

descendant

Выбирает всех потомков (детей, внуков и т.д.) текущего узла

descendant-or-self

Выбирает всех потомков (детей, внуков и т.д.) текущего узла и сам текущий узел

following

Выбирает всё в документе после закрытия тэга текущего узла

following-sibling

Выбирает все узлы одного уровня после текущего узла

namespace

Выбирает все узлы в данном пространстве имён (namespace) текущего узла

parent

Выбирает родителя текущего узла

preceding

Выбирает все узлы, которые появляются перед текущим узлом в документе, за исключением предков, узлов атрибутов и узлы пространства имён

preceding-sibling

Выбирает всех братьев и сестёр до текущего узла

self

Выбирает текущий узел

## 6_Выражения_пути выборки

Путь определения местоположения может быть абсолютным или относительным. Абсолютный путь расположения начинается с косой черты (/), а относительный – нет. В обоих случаях путь выборки состоит из одного или нескольких шагов, разделённых косой чертой:

Абсолютный путь расположения:

/step/step/...

Относительный путь выборки расположения:

step/step/...

Каждый шаг оценивается по узлам в текущем наборе узлов. Шаг состоит из:

-   ось (определяет древовидную связь между выбранными узлами и текущим узлом);
-   проверка узла (идентифицирует узел в пределах оси);
-   ноль или более предикатов (для дальнейшего уточнения выбранного набор узлов)

Синтаксис шага выборки такой:

axisname::nodetest[predicate] имяОси::проверкаУзла[предиктор]

Пример

Результат

child::book

Выбирает все узлы «книга» (book), которые являются потомками текущего узла

attribute::lang

Выбирает атрибут «язык» (lang) текущего узла

child::*

Выбирает всех потомков текущего узла

attribute::*

Выбирает все атрибуты текущего узла

child::text()

Выбирает все текстовые узлы текущего узла

child::node()

Выбирает всех ближайших потомков текущего узла

descendant::book

Выбирает всех потомков текущего узла

ancestor::book

Выбирает всех предков «книга» (books) текущего узла

ancestor-or-self::book

Выбирает всех предков «книга» (book) текущего узла – и текущий узел, если он также «книга» (book)

child::*/child::price

Выбирает все потомки «цена» (price) через один уровень от текущего узла

## 7_Операторы_ XPath

Выражения XPath возвращают как набор узлов, строки, булевы или числовые значения. Ниже представлен список операторов, используемых в выражениях XPath:

Оператор

Описание

Пример

|

Вычисляет два набора узлов

//book | //cd

+

Сложение

6 + 4

-

Вычитание

6 - 4

*

Умножение

6 * 4

div

Деление

8 div 4

=

Равенство

price=9.80

!=

Неравенство

price!=9.80

<

Меньше, чем

price<9.80

<=

Меньше или равно

price≤9.80

>

Больше, чем

price>9.80

>=

Больше или равно

price≤9.80

or

Или

price=9.80 or price=9.70

and

И

price>9.00 and price<9.90

mod

Остаток от деления

5 mod 2

## 8_Примеры_ XPath

Давайте рассмотрим базовый синтаксис XPath на нескольких примерах. Мы будем использовать следующий XML документ "books.xml" в примерах ниже:

<?xml version="1.0" encoding="UTF-8"?> <bookstore> <book category="COOKING"> <title lang="en">Everyday Italian</title> <author>Giada De Laurentiis</author> <year>2005</year> <price>30.00</price> </book> <book category="CHILDREN"> <title lang="en">Harry Potter</title> <author>J K. Rowling</author> <year>2005</year> <price>29.99</price> </book> <book category="WEB"> <title lang="en">XQuery Kick Start</title> <author>James McGovern</author> <author>Per Bothner</author> <author>Kurt Cagle</author> <author>James Linn</author> <author>Vaidyanathan Nagarajan</author> <year>2003</year> <price>49.99</price> </book> <book category="WEB"> <title lang="en">Learning XML</title> <author>Erik T. Ray</author> <year>2003</year> <price>39.95</price> </book> </bookstore>

#### Загрузка XML документа

Используйте XMLHttpRequest для загрузки XML документов, который поддерживается большинством современных браузеров:

var xmlhttp=new XMLHttpRequest()

Код для устаревших браузеров Microsoft (IE 5 и 6):

var xmlhttp=new ActiveXObject("Microsoft.XMLHTTP")

#### Выбор узлов

К сожалению, работа с XPath в Internet Explorer и в других браузерах может отличаться. В наших примерах мы будем использовать код, который должен работать в большинстве браузеров. Internet Explorer использует метод "selectNodes()" для выбора узлов XML документа:

xmlDoc.selectNodes(xpath);

Firefox, Chrome, Opera и Safari используют метод evaluate() для выбора узлов из XML документа:

xmlDoc.evaluate( xpath, xmlDoc, null, XPathResult.ANY_TYPE, null );

#### Выбор всех заглавий

Следующий пример выбирает все узлы заголовков:

/bookstore/book/title

#### Выбор заголовка первой книги

Следующий пример выбирает заголовок первого узла «книга» после элемента «книжный магазин» (bookstore):

/bookstore/book[1]/title

#### Выбор всех цен

Следующий пример выбирает текст всех узлов «цена» (price):

/bookstore/book/price[text()]

#### Выбирает узлы с ценой >35

Следующий пример выбирает все узлы с ценами выше 35:

/bookstore/book[price>35]/price

#### Выбор узлов заголовков с ценой >35

Следующий пример выбирает все узлы заголовков с ценой выше 35:

/bookstore/book[price>35]/title

### Скачать вложения:

-   [Скачать справочник по XPath на английском языке](https://soltau.ru/index.php/themes/dev/item/download/89_01928869eec41dea276e03a610307cba) (1008 Скачиваний)
-   [Скачать справочник по XPath на русском языке](https://soltau.ru/index.php/themes/dev/item/download/90_37487a662073d0788c348084ee05a3cd) (4115 Скачиваний)
_____________
#### Links
https://soltau.ru/index.php/themes/dev/item/413
[[CSS selectors]]