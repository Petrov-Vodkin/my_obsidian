2021-09-28 21:20

# Магические методы

| Магический метод | Когда он вызывается (пример) | Объяснение|
|------------------|------------------------------|-----------|
|`__new__(cls [,...])`|`instance = MyClass(arg1, arg2)`|`__new__` вызывается при создании экземпляра|
|`__init__(self [,...])`|`instance = MyClass(arg1, arg2)`|`__init__` вызывается при создании экземпляра
|`__cmp__(self, other)`|`self == other`, `self > other`, etc.|Вызывается для любого сравнения
|`__pos__(self)`|`+self`|Унарный знак плюса
|`__neg__(self)`|`-self`|Унарный знак минуса
|`__invert__(self)`|`~self`|Побитовая инверсия
|`__index__(self)`|`x[self]`|Преобразование, когда объект используется как индекс
|`__nonzero__(self)`|`bool(self)`, `if self:`|Булевое значение объекта
|`__getattr__(self, name)`|`self.name # name не определено`|Пытаются получить несуществующий атрибут
|`__setattr__(self, name, val)`|`self.name = val`|Присвоение любому атрибуту
|`__delattr__(self, name)`|`del self.name`|Удаление атрибута
|`__getattribute__(self, name)`|`self.name`|Получить любой атрибут
|`__getitem__(self, key)`|`self[key]`|Получение элемента через индекс
|`__setitem__(self, key, val)`|`self[key] = val`|Присвоение элементу через индекс
|`__delitem__(self, key)`|`del self[key]`|Удаление элемента через индекс
|`__iter__(self)`|`for x in self`|Итерация
|`__contains__(self, value)`|`value in self`, `value not in self`|Проверка принадлежности с помощью `in`
|`__call__(self [,...])`|`self(args)`|«Вызов» экземпляра
|`__enter__(self)`|`with self as x:`|`with` оператор менеджеров контекста
|`__exit__(self, exc, val, trace)`|`with self as x:`|`with` оператор менеджеров контекста
|`__getstate__(self)`|`pickle.dump(pkl_file, self)`|Сериализация
|`__setstate__(self)`|`data = pickle.load(pkl_file)`|Сериализация

### Конструирование и инициализация.

#### v1
#### _`object.__new__(cls[, ...])`_:

Метод `object.__new__()` вызывается для создания нового экземпляра класса `cls.__new__()` - это статический метод (в специальном регистре, поэтому не нужно объявлять его как таковой), который принимает в качестве первого аргумента класс `cls`, экземпляр которого был запрошен. Остальные аргументы передаются в выражение [конструктора объекта](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__init__) при вызове класса. Возвращаемое значение метода `__new__()` должно быть новым экземпляром объекта (обычно экземпляром `cls`).

Типичные реализации создают новый экземпляр класса, вызывая метод суперкласса `__new__()` с использованием `super().__new__(cls [, ...])` с соответствующими аргументами, а затем при необходимости изменяя вновь созданный экземпляр перед его возвратом.

Если `__new__()` вызывается во время создания объекта и возвращает экземпляр или подкласс `cls`, тогда метод [`__init__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__init__) нового экземпляра будет вызываться как `__init__(self [, ...])`, где `self` - это новый экземпляр, а остальные аргументы те же, что были переданы конструктору объекта.

Если `__new__()` не возвращает экземпляр `cls`, то метод `__init__()` нового экземпляра не вызывается.

Специальный метод `__new__()` предназначен в основном для того, чтобы позволить подклассам неизменяемых типов (например, [`int`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-int-tselye-chisla/ "Тип данных int, целые числа"), [`str`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Тип данных str в Python.") или [`tuple`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/ "Тип данных tuple, кортеж")) настраивать создание экземпляров. Он также обычно переопределяется в настраиваемых метаклассах, для настройки создания класса.

#### _`object.__init__(self[, ...])`_:

Метод `object.__init__()` представляет собой конструктор класса и вызывается после создания экземпляра (с помощью [`__new__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__new__)), но до того, как он будет возвращен вызывающей стороне. Аргументы передаются в выражение конструктора класса.

Если базовый класс имеет метод `__init__()`, то метод производного класса `__init__()`, если таковой имеется, должен явно вызывать его, чтобы обеспечить правильную инициализацию части экземпляра базового класса; например: [`super().__init__([args ...])`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-super/ "Функция super() в Python, доступ к унаследованным методам.").

Поскольку магические методы `__new__()` и `__init__()` работают вместе при создании объектов (`__new__()` для его создания, а `__init__()` для его настройки), то метод `__init__()` не может возвращать значения, отличные от `None`. Это приведет к возникновению [ошибки `TypeError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.") во время выполнения.
```py
class Order:
    # конструктор класса
    def __init__(self, price, num):
        self.price = price
        self.num = num
    
    def __getattr__(self, attrname):
        if attrname == "total":
            return self.price * self.num

>>> order = Order(10, 15)
>>> order.price
# 10
>>> order.num
# 15
>>> order.total
# 150
```
#### _`object.__del__(self)`_:

Метод `object.__del__()` вызывается, когда экземпляр класса будет уничтожен. Это также называется финализатором или (неправильно) деструктором.

Если базовый класс имеет метод `__del__()`, то метод производного класса `__del__()`, если таковой имеется, должен явно вызывать его, чтобы обеспечить правильное удаление части экземпляра базового класса.

Возможно (хотя и не рекомендуется!) метод `__del__()` может откладывать уничтожение экземпляра, создав на него новую ссылку. Это называется воскрешением объекта. Такое поведение зависит от реализации, может ли `__del__()` вызываться второй раз, когда воскресший объект должен быть уничтожен. Текущая реализация CPython вызывает его только один раз.

Не гарантируется, что методы `__del__()` будут вызваны для объектов, которые все еще существуют, когда интерпретатор завершает работу.

_Обратите внимание_, что выражение `del x` не вызывает напрямую `x.__del__()` - первый уменьшает счетчик ссылок для `x` на единицу, а второй вызывается только тогда, когда счетчик ссылок `x` достигает нуля.

Детали реализации CPython: цикл ссылок может предотвратить обнуление счетчика ссылок объекта. В этом случае цикл будет позже обнаружен и удален циклическим сборщиком мусора. Частая причина циклов обращения - это когда исключение было перехвачено в локальной переменной. Затем локальные переменные кадра ссылаются на исключение, которое ссылается на собственную трассировку, которая ссылается на локальные переменные всех кадров, перехваченных трассировкой.

**Предупреждение**. Из-за сомнительных обстоятельств, при которых вызываются методы `__del__()`, исключения, возникающие во время их выполнения, игнорируются, а вместо них в [`sys.stderr`](https://docs-python.ru/standart-library/modul-sys-python/obekty-stdin-stdout-stderr-modulja-sys/ "Объекты stdin, stdout, stderr модуля sys в Python.") выводится предупреждение.

В частности:

-   специальный метод `__del__()` может быть вызван при выполнении произвольного кода, в том числе из любого произвольного потока. Если `__del__()` необходимо принять блокировку или вызвать любой другой блокирующий ресурс, он может заблокироваться, поскольку ресурс уже может быть занят кодом, который прерывается для выполнения `__del__()`.
    
-   метод `__del__()` может вызываться во время завершения работы интерпретатора. Как следствие, глобальные переменные, к которым он должен получить доступ (включая другие модули), возможно, уже были удалены или установлены на `None`. Python гарантирует, что глобальные объекты, имя которых начинается с одного символа подчеркивания, удаляются из своего модуля до того, как будут удалены другие глобальные объекты. Если других ссылок на такие глобальные объекты не существует, это может помочь гарантировать, что импортированные модули все еще доступны во время вызова метода `__del__()`.
    

#### _`object.__repr__(self)`_:

Метод `object.__repr__()` вызывается встроенной [функцией `repr()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-repr/ "Функция repr() в Python, описание объекта.") для вычисления _официального_ строкового представления объекта. Если это вообще возможно, то это должно выглядеть как допустимое выражение Python, которое можно было бы использовать для воссоздания объекта с тем же значением (в соответствующей среде). Если это невозможно, то должна быть возвращена строка формы `<...some useful description...>` (какое-то полезное описание). Возвращаемое значение должно быть [строковым объектом](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Тип данных str в Python."). Если класс определяет специальный метод `__repr__()`, но не [`__str__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__str__), то тогда `__repr__()` также используется, когда требуется [_неформальное_ строковое представление](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__str__) экземпляров этого класса.

Обычно этот метод используется для отладки, поэтому важно, чтобы представление было точным, насыщенным и однозначным.
```py
class Order:
    def __init__(self, price, num):
        self.price = price
        self.num = num
    
    def __getattr__(self, attrname):
        if attrname == "total":
            return self.price * self.num

    # официальное строковое представление
    def __repr__(self):
        return f'{self.__class__.__name__}(price={self.price},\
 num={self.num}, total={self.total})'

>>> order = Order(10, 15)
>>> repr(order)
# 'Order(price=10, num=15, total=150)'
```
#### _`object.__str__(self)`_:

Метод `object.__str__()` вызывается встроенной [функцией `str()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-str/ "Класс str() в Python, преобразует объект в строку.") и встроенными функциями [`format()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-format/ "Функция format() в Python, форматирует значение переменной.") и [`print()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-print/ "Функция print() в Python, печатает объект.") для вычисления _неформального_ или _красиво_ печатаемого строкового представления объекта. Возвращаемое значение должно быть [строковым объектом](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Тип данных str в Python.").

Этот метод отличается от специального метода [`object.__repr__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__repr__) тем, что не ожидается, что `__str__()` вернет допустимое выражение Python: можно использовать более удобное или краткое представление.

Реализация по умолчанию, определяемая объектом встроенного типа, вызывает `object.__repr__()`.
```py
class Order:
    def __init__(self, price, num):
        self.price = price
        self.num = num
    
    def __getattr__(self, attrname):
        if attrname == "total":
            return self.price * self.num

    # неформальное строковое представление
    def __str__(self):
        return f'price={self.price}, num={self.num}, total={self.total}'

>>> order = Order(10, 15)
>>> str(order)
# 'price=10, num=15, total=150'
```
#### _`object.__bytes__(self)`_:

Метод `object.__bytes__()` вызывается встроенной [функцией `bytes()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-bytes/ "Класс bytes() в Python, преобразует в строку байтов.") для вычисления представления объекта в виде [байтовой строки](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/ "Тип данных bytes, байтовые строки"). Возвращаемое значение должно быть байтовым объектом.

#### _`object.__format__(self, format_spec)`_:

Метод `object.__format__()` вызывается встроенной [функцией `format()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-format/ "Функция format() в Python, форматирует значение переменной.") и, по расширению, вычислением форматированных строковых литералов и [методом `str.format()`](https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/metod-str-format/ "Метод str.format() в Python, форматирует строку.") для создания _форматированного_ строкового представления объекта.

Аргумент `format_spec` - это строка, содержащая описание желаемых параметров форматирования. Интерпретация аргумента `format_spec` зависит от типа, реализующего специальный метод `__format__()`, но большинство классов либо делегируют форматирование одному из встроенных типов, либо используют аналогичный синтаксис параметра форматирования.

Описание стандартного синтаксиса форматирования смотрите в документации к [функцией `format()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-format/ "Функция format() в Python, форматирует значение переменной.").

Возвращаемое значение должно быть [строковым объектом](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Тип данных str в Python.").

Изменено в версии 3.7: `object.__format__(x, '')` теперь эквивалентен `str(x)`, а не `format(str(x), '')`.

#### _`object.__lt__(self, other)`_,  
_`object.__le__(self, other)`_,  
_`object.__eq__(self, other)`_,  
_`object.__ne__(self, other)`_,  
_`object.__gt__(self, other)`_,  
_`object.__ge__(self, other)`_:

Перечисленные методы - называются методами _расширенного сравнения_.

Соответствие между символами операторов и именами методов следующее:

-   `x < y`: вызывает `x.__lt__(y)`,
-   `x <= y`: вызывает `x.__le__(y)`,
-   `x == y` вызывает `x.__eq__(y)`,
-   `x != y` вызывает `x.__ne__(y)`,
-   `x > y` вызывает `x.__gt__(y)`,
-   `x >= y` вызывает `x.__ge__(y)`.

Методы расширенного сравнения могут возвращать [одиночный объект `NotImplemented`](https://docs-python.ru/tutorial/vstroennye-konstanty-jazyka-python/ "Встроенные константы языка Python."), если он не реализует операцию для данной пары аргументов. По соглашению, для успешного сравнения возвращаются [`False` и `True`](https://docs-python.ru/tutorial/vstroennye-konstanty-jazyka-python/ "Встроенные константы языка Python."). Однако эти методы могут возвращать любое значение, поэтому, если оператор сравнения используется в логическом контексте (например, в условии [оператора if](https://docs-python.ru/tutorial/tsikly-upravlenie-vetvleniem-python/uslovie-if-elif-else/ "Проверка условий, конструкция  if/elif/else в Python.")), Python для значения вызовет [функцию `bool()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-bool/ "Класс bool() в Python, логическое значение объекта."), чтобы определить, является ли результат истинным или ложным.

По умолчанию объект реализует `__eq__()` с помощью [оператора `is`](https://docs-python.ru/tutorial/operator-identichnosti-is-is-not-python/ "Оператор идентичности is в Python."), возвращая `NotImplemented` в случае ложного сравнения: `True`, если `x` идентично `y`, иначе `NotImplemented`. Метод `__ne__()` по умолчанию делегирует `__eq__()` и инвертирует результат, если он не `NotImplemented`. Других подразумеваемых отношений между операторами сравнения или реализациями по умолчанию нет; например, истинность `(x<y or x==y)` не означает `x<=y`. Чтобы автоматически генерировать операции упорядочивания из одной корневой операции, смотрите [`functools.total_ordering()`](https://docs-python.ru/standart-library/modul-functools-python/dekorator-total-ordering-modulja-functools/ "Декоратор @total_ordering модуля functools в Python.") ().

Смотрите [описание метода `__hash__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/#object.__hash__) для некоторых важных замечаний по созданию хешируемых объектов, которые поддерживают настраиваемые [операции сравнения](https://docs-python.ru/tutorial/operatsii-sravnenija-python/ "Операторы/операции сравнения (цепочки сравнений) в Python.") и могут использоваться как ключи словаря.

У этих специальных методов не существует версий с заменяемыми аргументами (для использования, когда левый аргумент не поддерживает операцию, а правый аргумент поддерживает). Скорее, метод `__lt__()` это отражение `__gt__()` и наоборот, `__le__()` это отражение `__ge__()` и наоборот, а `__eq__()` и `__ne__()` - их собственное отражение. Если операнды имеют разные типы, а тип правого операнда является прямым или косвенным подклассом типа левого операнда, то отраженный метод правого операнда имеет приоритет, в противном случае метод левого операнда имеет приоритет. Виртуальный подкласс не рассматривается.

#### _`object.__hash__(self)`_:

Метод `object.__hash__()` вызывается встроенной [функцией `hash()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-hash/ "Функция hash() в Python, хэш-значение объекта.") и для операций с элементами хешированных коллекций, включая `set`, `frozenset` и `dict`. Специальный метод `__hash__()` должен возвращать [целое число](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-int-tselye-chisla/ "Тип данных int, целые числа"). Единственное обязательное свойство - это то, что сравниваемые одинаковые объекты имеют одинаковое хеш-значение. Рекомендуется смешивать вместе хеш-значения компонентов объекта, которые также играют роль в сравнении объектов, упаковывая их в [кортеж](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/ "Тип данных tuple, кортеж") и вычислять хэш значение кортежа.

Пример:

def __hash__(self):
    return hash((self.name, self.nick, self.color))

Обратите внимание, что функция [`hash()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-hash/ "Функция hash() в Python, хэш-значение объекта.") обрезает значение, возвращаемое пользовательским методом `__hash__()` объекта, до размера `Py_ssize_t`. Обычно это 8 байтов для 64-разрядных сборок и 4 байта для 32-разрядных сборок. Если `__hash__()` объекта должен взаимодействовать со сборками с разным размером бит, то обязательно проверьте это во всех поддерживаемых сборках. Простой способ сделать это - использовать `python -c 'import sys; print(sys.hash_info.width)'`.

Если класс не определяет метод `__eq__()`, то он также не должен определять метод `__hash__()`. Если класс определяет `__eq__()`, но не определяет `__hash__()`, то его экземпляры не будут использоваться как элементы в хэшируемых коллекциях. Если класс определяет изменяемые объекты и реализует метод `__eq__()`, то он не должен реализовывать метод `__hash__()`, поскольку реализация хешируемых коллекций требует, чтобы хеш-значение ключа было неизменным (если хеш-значение объекта изменится, то хеш будет неверным).

Пользовательские классы по умолчанию имеют методы `__eq__()` и `__hash__()`. С ними все объекты сравниваются как неравные кроме самих себя, а `x.__hash__()` возвращает соответствующее значение, так что `x == y` подразумевает, что `x is y` и `hash(x) == hash(y)`.

Класс, который переопределяет `__eq__()` и не определяет `__hash__()`, будет иметь для своего метода `__hash__()` неявное значение `None`. Если для метода класса `__hash__()` установлено значение `None`, то экземпляры класса вызовут соответствующую [ошибку `TypeError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python."), когда программа попытается получить их хеш-значение, а также будут правильно идентифицированы как нехешируемые при проверке `isinstance(obj, collections.abc.Hashable)`.

Если класс, который переопределяет `__eq__()` и вместе с этим должен сохранить реализацию `__hash__()` из родительского класса, то интерпретатору об этом необходимо сообщить явно, установив `__hash__ = ParentClass.__hash__`.

Если класс, который не переопределяет `__eq__()` и желает подавить поддержку хэша, то он должен включить в определение класса `__hash__ = None`. Класс, который определяет свой собственный `__hash__()`, который явно вызывает `TypeError`, будет неправильно идентифицирован как хешируемый при вызове `isinstance(obj, collections.abc.Hashable)`.

_Примечание_. По умолчанию значения метода `__hash__()` объектов `str` и `bytes` _подсолены_ непредсказуемым случайным значением. Хотя они остаются постоянными в рамках отдельного процесса Python, их нельзя предсказать между повторными вызовами Python.

Это предназначено для обеспечения защиты от отказа в обслуживании, вызванного тщательно подобранными входными данными, которые используют наихудшую производительность вставки [`dict`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-dict-slovar/ "Тип данных dict, словарь"), сложность `O(n^2)`.

Изменение значений хеш-функции влияет на порядок итерации множества. Python никогда не давал гарантий относительно этого порядка и обычно он по разному варьируется между 32-битными и 64-битными сборками.

Смотрите также описание переменной окружения интерпретатора [`PYTHONHASHSEED`](https://docs-python.ru/tutorial/zapusk-skriptov-python3-komandnoj-stroki/peremennye-sredy-okruzhenija/ "Переменные среды окружения Python.").

#### _`object.__bool__(self)`_:

Метод `object.__bool__()` вызывается для реализации проверки истинности и встроенной [функцией `bool()`](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/klass-bool/ "Класс bool() в Python, логическое значение объекта."). Метод должен вернуть `False` или `True`.

Когда этот магический метод не определен, то вызывается специальный метод [`__len__()`](https://docs-python.ru/tutorial/klassy-jazyke-python/emuljatsija-tipov-kontejnerov-klassah/ "Эмуляция контейнерных типов в классах Python."), если он определен, и объект считается истинным, если его результат не равен нулю. Если класс не определяет ни `__len__()`, ни `__bool__()`, то все его экземпляры считаются истинными.

# v2
Всем известен самый базовый магический метод, `__init__`. С его помощью мы можем инициализировать объект. Однако, когда я пишу `x = SomeClass()`, `__init__` не самое первое, что вызывается. На самом деле, экземпляр объекта создаёт метод `__new__`, а затем аргументы передаются в инициализатор. На другом конце жизненного цикла объекта находится метод `__del__`. Давайте подробнее рассмотрим эти три магических метода:  
#### **`__new__(cls, [...)`  **
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в `__init__`. `__new__` используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. Я не намерен очень детально останавливаться на `__new__`, так как он не то чтобы очень часто нужен, но этот метод очень хорошо и детально описан в [документации](http://www.python.org/download/releases/2.2/descrintro/#__new__).  
#### **`__init__(self, [...)`**  
Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем `x = SomeClass(10, 'foo')`, `__init__` получит `10` и `'foo'` в качестве аргументов. `__init__` почти повсеместно используется при определении классов.  
#### **`__del__(self)`**  
Если `__new__` и `__init__` образуют конструктор объекта, `__del__` это его деструктор. Он не определяет поведение для выражения `del x` (поэтому этот код не эквивалентен `x.__del__()`). Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты. Однако, нужно быть осторожным, так как нет гарантии, что `__del__` будет вызван, если объект продолжает жить, когда интерпретатор завершает работу. Поэтому `__del__` не может служить заменой для хороших программистских практик (всегда завершать соединение, если закончил с ним работать и тому подобное). Фактически, из-за отсутствия гарантии вызова, `__del__` не должен использоваться почти никогда; используйте его с осторожностью!  
**Замечание от переводчика:** [svetlov](https://habrahabr.ru/users/svetlov/) [отмечает](https://habr.com/ru/post/186608/#comment_6492862), что здесь автор ошибается, на самом деле `__del__` всегда вызывается по завершении работы интерпретатора.
	
`__dict__`, `__doc__`, `__ slots__`
_____________
#### Links
https://docs-python.ru/tutorial/klassy-jazyke-python/bazovaja-nastrojka-klassov/
https://habr.com/ru/post/186608/
[[ООП]]